<!DOCTYPE html>
<html
  lang="en"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>《Go语言实战》读书笔记 | JoyBoy&#39;s blog</title>

<meta name="generator" content="Hugo Eureka 0.9.1" />
<link rel="stylesheet" href="https://zyooo.github.io/css/eureka.min.6a378a23360d238dc3ef4df2f5cd718093f02c10c9c7eb2437c29701cd8d389ab6da5d9f21bdd3afa305fd56c1235017.css" integrity="sha384-ajeKIzYNI43D703y9c1xgJPwLBDJx&#43;skN8KXAc2NOJq22l2fIb3Tr6MF/VbBI1AX">
<script defer src="https://zyooo.github.io/js/eureka.min.f1639ee98d6cbd85b2b5f034d27320da962002ff83159ed4e01dbc5948c42a1ab26c2d6e74c66e93f5cec4d24dbd166d.js" integrity="sha384-8WOe6Y1svYWytfA00nMg2pYgAv&#43;DFZ7U4B28WUjEKhqybC1udMZuk/XOxNJNvRZt"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/stackoverflow-dark.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>


<script defer type="text/javascript" src="https://zyooo.github.io/js/fontawesome.min.1c5a4674b042785ed214cf0818a81724c6b37442fd61b0ed039237b93de25ed5103fc8079a05770648ccc9c66c4f540a.js" integrity="sha384-HFpGdLBCeF7SFM8IGKgXJMazdEL9YbDtA5I3uT3iXtUQP8gHmgV3BkjMycZsT1QK"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="https://zyooo.github.io/images/icon_hu0887349992b35fe0daec5472ae05fa5f_87705_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://zyooo.github.io/images/icon_hu0887349992b35fe0daec5472ae05fa5f_87705_180x180_fill_box_center_3.png">

<meta name="description"
  content="Go语言实战 记录《Go语言实战》中自己觉得需要学习的点">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"GolangDairies",
      "item":"https://zyooo.github.io/golangdairy/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"《Go语言实战》读书笔记",
      "item":"https://zyooo.github.io/golangdairy/test/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://zyooo.github.io/golangdairy/test/"
    },
    "headline": "《Go语言实战》读书笔记 | JoyBoy\u0027s blog","datePublished": "2022-03-28T22:27:47+08:00",
    "dateModified": "2022-03-28T22:27:47+08:00",
    "wordCount":  2329 ,
    "publisher": {
        "@type": "Person",
        "name": "ZhangYong",
        "logo": {
            "@type": "ImageObject",
            "url": "https://zyooo.github.io/images/icon.png"
        }
        },
    "description": "Go语言实战 记录《Go语言实战》中自己觉得需要学习的点"
}
</script><meta property="og:title" content="《Go语言实战》读书笔记 | JoyBoy&#39;s blog" />
<meta property="og:type" content="article" />


<meta property="og:image" content="https://zyooo.github.io/images/icon.png">


<meta property="og:url" content="https://zyooo.github.io/golangdairy/test/" />




<meta property="og:description" content="Go语言实战 记录《Go语言实战》中自己觉得需要学习的点" />




<meta property="og:locale" content="en" />




<meta property="og:site_name" content="JoyBoy&#39;s blog" />






<meta property="article:published_time" content="2022-03-28T22:27:47&#43;08:00" />


<meta property="article:modified_time" content="2022-03-28T22:27:47&#43;08:00" />



<meta property="article:section" content="GolangDairy" />





  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">JoyBoy&#39;s blog</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">About</a>
            <a href="/note/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">Notes</a>
            <a href="/leetcodedairy/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">LeetCodeDairy</a>
            <a href="/javadairy/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">JavaDairy</a>
            <a href="/golangdairy/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">GolangDairy</a>
            <a href="/bugs/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">Bugs</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">Light</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">《Go语言实战》读书笔记</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2022-03-28</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>11 min read</span>
  </div>

  

  
</div>


  
  

  <h1 id="go语言实战">Go语言实战</h1>
<p>记录《Go语言实战》中自己觉得需要学习的点</p>
<h2 id="第一章go语言介绍">第一章：Go语言介绍</h2>
<p>优点：</p>
<pre><code>1. 语言层面支持并发，更加高效的利用服务器上的所有核心

2. 自带垃圾回收器

3. 提供了灵活的、无继承的类型系统，使用组合的设计模式，将类型嵌入就能复用功能

4. 更加智能的编译器，编译速度快
</code></pre>
<p>​</p>
<h2 id="第三章打包和go工具">第三章：打包和Go工具</h2>
<ol>
<li>
<p>包名惯例：使用包所在目录的名字，尽量使用简洁、清晰且全小写的名字。例如 net/http</p>
</li>
<li>
<p>所有用Go语言编译的可执行程序都必须有一个名叫main的包，main()函数是程序的入口。</p>
</li>
<li>
<p>远程导入</p>
<ul>
<li>用导入路径编译程序时，go build命令会使用GOPATH的设置在磁盘上搜索这个包</li>
<li>如果路径包含URL，例如 import &ldquo;github.com/spf13/viper&rdquo; 可以用Go工具链从DVCS（分布式版本控制系统）获取包</li>
<li>通过go get命令完成</li>
</ul>
</li>
<li>
<p>命名导入</p>
<ul>
<li>如果要导入多个包具有相同的名字,例如 network/convert  和 file/convert，就可以通过命名导入的方式来区分这两个包</li>
<li>import myfmt &ldquo;mylib/fmt&rdquo;</li>
</ul>
</li>
<li>
<p>空白标识符导入</p>
<ul>
<li>
<p>有时候我们需要导入一个包, 但是不需要引用这个包的标识符(例如驱动包), 但是导入一个包如果未在代码中使用的话, Go编译器就会编译失败, 这时候就可以用空白标识符 &ldquo;_&rdquo; 去给这个包赋予一个空名字</p>
</li>
<li>
<p>例如</p>
<pre><code class="language-go">package main 
import (
	&quot;database/sql&quot;
    _ &quot;github.com/goinaction/code/chapter3/dbdriver/postgres&quot;
)
func main() {
    sql.Open(&quot;postgres&quot;,&quot;mydb&quot;) 
    //该方法能工作的关键在于postgres驱动通过自身的init函数将自身注册到了sql包
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>go开发工具 :</p>
<ul>
<li>go fmt</li>
<li>go vet ( 检测错误 )</li>
<li>go doc 在命令行打印文档</li>
<li>godoc 启动自己的文档服务器 例如 godoc -http=:6060 (用了说没有godoc这个命令)</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/29/Zo85GwOrv2bugVj.png" alt="image-20220329154855682"></p>
<h2 id="第四章-数组切片和映射">第四章: 数组、切片和映射</h2>
<h3 id="数组">数组</h3>
<ol>
<li>
<p>数组是一个长度固定的数据类型, 所以长度也是数组的一个属性, 长度不同的数组是不相同的</p>
</li>
<li>
<p>数组的声明方式, 这里放两个比较特殊的</p>
<pre><code class="language-go">array := [...]int{1,2,3,4,5} //容量由初始化值的数量决定
array := [5]int{1: 10,2: 20} //声明特定索引的值
</code></pre>
</li>
<li>
<p>指针数组</p>
<pre><code class="language-go">array := [5]*int{0: new{int}, 1: new(int)}
//赋值
*array[0] = 10
//copy, 普通数组和指针数组都可以这样, 普通数组是复制之后两个数组的值完全一样
//指针数组是每一个对应元素都指向同一个值
var array2 [5]*int
array2 = array
</code></pre>
</li>
<li>
<p>多维数组略</p>
</li>
<li>
<p>传递大数组可以利用指针传递</p>
<pre><code class="language-go">var array [1e6]int
foo(&amp;array)
func foo (array *[1e6]int){
    ...
}
//foo接收一个指向100万个整型值的数组的指针只需要复制8字节而不是8MB
</code></pre>
</li>
</ol>
<h3 id="切片">切片</h3>
<ol>
<li>
<p>内部实现</p>
<ul>
<li>
<p>切片是一个很小的对象, 对底层数组进行了抽象</p>
</li>
<li>
<p><img src="https://s2.loli.net/2022/03/30/j2TrDN1oGJSay5P.png" alt="image-20220330080753227"></p>
</li>
<li>
<p>nil切片和空切片</p>
<pre><code class="language-go">var slice []int //如上图的nil切片
s := []int{} //或者 s := make([]int,0,0) 声明一个空切片
</code></pre>
</li>
<li>
<p><img src="https://s2.loli.net/2022/03/30/PXCHy7huOWaMdYe.png" alt="image-20220330081120866"></p>
</li>
<li>
<p>append的时候会在长度后添加元素, 但是不能访问超过长度的, 即使容量够大也属于越界访问</p>
</li>
<li>
<p><img src="https://s2.loli.net/2022/03/30/xndLHystrFQohgI.png" alt="image-20220330081422658"></p>
</li>
<li>
<p>append后底层数组不够用就会开辟新的数组空间然后将旧的数组复制过来</p>
</li>
<li>
<p><img src="https://s2.loli.net/2022/03/30/qh6vHIfQxAkaKjg.png" alt="image-20220330081631993"></p>
</li>
</ul>
</li>
<li>
<p>slice扩容规则:</p>
<ul>
<li>预估扩容后的容量
<ul>
<li>if oldCap*2 &lt; cap → newCap = cap</li>
<li>else
<ul>
<li>if oldLen &lt; 1024 → newCap = oldCap*2</li>
<li>if oldLen &gt;= 1024 →  newCap = oldCap*1.25</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/03/30/WJOCSYNMajrhEFb.png" alt="image-20220330082301568"></p>
<ol start="3">
<li>
<p>使用三个索引创建切片</p>
<pre><code class="language-go">slice := source[2:3:4] //长度为3 - 2 = 1, 容量为4 - 2 = 2 
</code></pre>
</li>
</ol>
<h3 id="映射map">映射map</h3>
<ol>
<li>映射的键可以是任何值, 这个值的类型可以是内置的类型, 也可以是结构类型, 只要这个值可以用==运算符作比较, 切片, 函数, 以及包含切片的结构类型这些具有引用语义的就不能作为映射的键, 但是可以作为映射的值</li>
<li>map需要经过make初始化之后才能使用, nil映射不能用于存储键值对, 否则会发生错误</li>
<li>使用delete(map, key) 来删除一个键值对</li>
<li>map的底层结构, 参考一篇专门的文章</li>
</ol>
<h2 id="第五章-go语言的类型系统">第五章: Go语言的类型系统</h2>
<ol>
<li>
<p>不同类型的变量赋值产生编译错误</p>
<pre><code class="language-go">package main

type Duration int64

func main() {
	var dur Duration
    dur = int64(100) //编译会通过不了, 因为在go看来int64和Duration是两种不同的类型
}
</code></pre>
</li>
<li>
<p>Go在代码后面执行的动作</p>
<pre><code class="language-go">type user struct {
    name string
    email string
}

func (u user)notify() {
    ...
}

func (u *user)changeEmail(email string) {
    ...
}

func main(){
    lisa := &amp;user{&quot;Lisa&quot;,&quot;xxxx@xxx.com&quot;}
    lisa.notify() 
    // (*lisa).notify(), notify操作的只是一个副本, 只不过这次操作的操作是从lisa指针指向的值的副本

    lisa.changeEmail(&quot;newEmail&quot;) 
    // (&amp;lisa).changeEmail(&quot;newEmail&quot;) 首先引用lisa得到一个指针
    //这样这个指针就能匹配方法接受者类型, 再进行调用
}
</code></pre>
</li>
<li>
<p>类型的本质</p>
<ul>
<li>在声明一个类型的方法之前, 首先思考一下 : 这个类型的本质是什么</li>
<li>如果给这个类型增加或者删除某个值, 是要创建一个新值, 还是要更改当前的值?
<ul>
<li>如果是要创建一个新值, 该类型的方法就是用值接收者</li>
<li>如果是要修改当前值, 就是用指针接收者</li>
</ul>
</li>
<li>保持传递的一致性很重要</li>
<li>编译器只允许为命名的用户定义的类型声明方法 func(xx XX)xxx(){}</li>
</ul>
</li>
<li>
<h3 id="接口">接口</h3>
<ul>
<li>
<p>接口是用来定义行为的<strong>类型</strong></p>
</li>
<li>
<p>被定义的行为不由接口直接实现, 而是通过方法由用户定义的类型实现</p>
</li>
<li>
<p>任何用户定义的类型都可以实现任何接口, 所以对接口值方法的调用自然是一种多态</p>
<pre><code class="language-go">package main

import &quot;fmt&quot;

// notifier 定义了一个通知类行为的接口
type notifier interface {
	notify()
}

// user 在程序里面定义一个用户类型
type user struct {
	name  string
	email string
}

// notify 是使用指针接收者实现的方法
func (u *user) notify() {
	fmt.Printf(&quot;Sending user email to %s&lt;%s&gt;\n&quot;, u.name, u.email)
}

func main() {
	u := user{&quot;bill&quot;, &quot;bill@email.com&quot;}
	//sendNotification(u)
	//Cannot use 'u' (type user) as the type notifier Type
	//does not implement 'notifier' as the 'notify' method has a pointer receiver
	//因为notify使用的是指针接收者, 所以user并没有实现接口, 而*user实现了, 所以要传入&amp;u才行
	sendNotification(&amp;u)
	//但是在上面改成(u user)之后, 传入u或者&amp;u都可以实现
}

func sendNotification(n notifier) {
	n.notify()
}

</code></pre>
</li>
<li>
<p>多态, 如上例可以新增一个admin类型, 同样实现notify()方法, 但是里面的内容可以多样, 同样调用sendNotification()就能发送不同的值了</p>
</li>
</ul>
</li>
<li>
<h3 id="嵌入类型">嵌入类型</h3>
<ol>
<li>
<p>内部类型的方法(接口)被提升到外部类型</p>
<pre><code class="language-go">// Sample program to show how embedded types work with interfaces.
package main

import (
	&quot;fmt&quot;
)

// notifier is an interface that defined notification
// type behavior.
type notifier interface {
	notify()
}

// user defines a user in the program.
type user struct {
	name  string
	email string
}

// notify implements a method that can be called via
// a value of type user.
func (u *user) notify() {
	fmt.Printf(&quot;Sending user email to %s&lt;%s&gt;\n&quot;,
		u.name,
		u.email)
}

// admin represents an admin user with privileges.
type admin struct {
	user
	level string
}

// main is the entry point for the application.
func main() {
	// Create an admin user.
	ad := admin{
		user: user{
			name:  &quot;john smith&quot;,
			email: &quot;john@yahoo.com&quot;,
		},
		level: &quot;super&quot;,
	}
	ad.user.notify()  
	ad.notify() //方法提升
	// Send the admin user a notification.
	// The embedded inner type's implementation of the
	// interface is &quot;promoted&quot; to the outer type.
	sendNotification(&amp;ad)  //接口提升
}

// sendNotification accepts values that implement the notifier
// interface and sends notifications.
func sendNotification(n notifier) {
	n.notify()
}

/*
OutPut:
	Sending user email to john smith&lt;john@yahoo.com&gt;
    Sending user email to john smith&lt;john@yahoo.com&gt;
    Sending user email to john smith&lt;john@yahoo.com&gt;
*/
</code></pre>
</li>
<li>
<p>外部类型使用自己的一套实现</p>
<pre><code class="language-go">// Sample program to show what happens when the outer and inner
// type implement the same interface.
package main

import (
	&quot;fmt&quot;
)

// notifier is an interface that defined notification
// type behavior.
type notifier interface {
	notify()
}

// user defines a user in the program.
type user struct {
	name  string
	email string
}

// notify implements a method that can be called via
// a value of type user.
func (u *user) notify() {
	fmt.Printf(&quot;Sending user email to %s&lt;%s&gt;\n&quot;,
		u.name,
		u.email)
}

// admin represents an admin user with privileges.
type admin struct {
	user
	level string
}

// notify implements a method that can be called via
// a value of type Admin.
func (a *admin) notify() {
	fmt.Printf(&quot;Sending admin email to %s&lt;%s&gt;\n&quot;,
		a.name,
		a.email)
}

// main is the entry point for the application.
func main() {
	// Create an admin user.
	ad := admin{
		user: user{
			name:  &quot;john smith&quot;,
			email: &quot;john@yahoo.com&quot;,
		},
		level: &quot;super&quot;,
	}

	// Send the admin user a notification.
	// The embedded inner type's implementation of the
	// interface is NOT &quot;promoted&quot; to the outer type.
	sendNotification(&amp;ad)
	//Send admin ...

	// We can access the inner type's method directly.
	ad.user.notify()
	//Send user ...

	// The inner type's method is NOT promoted.
	ad.notify()
    //Send admin ...
}

// sendNotification accepts values that implement the notifier
// interface and sends notifications.
func sendNotification(n notifier) {
	n.notify()
}
</code></pre>
</li>
<li>
<p>公开与未公开标识符 : 开头字母大小写, 小写的不能被在包外显示创建</p>
</li>
</ol>
</li>
</ol>
<h2 id="第六章-并发">第六章: 并发</h2>
<h3 id="并发与并行">并发与并行</h3>
<ol>
<li>并行 parallelism : 同时做很多事情</li>
<li>并行 concurrency : 同时管理很多事情</li>
</ol>
<h3 id="goroutine">goroutine</h3>
<ol>
<li>
<p>GMP模型看另外文章</p>
</li>
<li>
<p>修改逻辑处理器的数量</p>
<pre><code class="language-go">...
func main() {
    runtime.GOMAXPROCS(1) //有点并发的感觉, 也有可能第一个函数时间非常短在切换调度之前就结束了, 看起来就像串行
    runtime.GOMAXPROCS(runtime.NumCPU())  //给每个一物理处理器都创建一个逻辑处理器
}
</code></pre>
</li>
</ol>
<h3 id="竞争状态">竞争状态</h3>
<ol>
<li>
<p>示例代码</p>
<pre><code class="language-go">// Sample program to show how embedded types work with interfaces.
package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
)

var (
	//counter 是所有 goroutine 都要增加其值的变量
	counter int
	//wg 用来等待程序结束
	wg sync.WaitGroup
)

// main is the entry point for the application.
func main() {
	wg.Add(2)

	//创建两个goroutine
	go incCounter(1)
	go incCounter(2)
	wg.Wait()
	fmt.Println(&quot;Final Counter&quot;, counter)
}

func incCounter(id int) {
	defer wg.Done()
	for count := 0; count &lt; 2; count++ {
		//捕获counter的值
		value := counter

		//当前goroutine从线程退出, 并放回到队列
		runtime.Gosched()
		value++
		counter = value
	}
}

</code></pre>
</li>
<li>
<p>最终的答案是2, 因为有个runtime.Gosched() , 具体流程看下图</p>
<p><img src="https://s2.loli.net/2022/04/01/Kekwahq4sopRHlx.jpg" alt="4135ab13a043e8a35dec975c4bd3100"></p>
</li>
</ol>
<h3 id="锁">锁</h3>
<ol>
<li>
<h4 id="原子函数">原子函数</h4>
<ul>
<li>
<p>保护共享资源</p>
<pre><code class="language-go">// Sample program to show how embedded types work with interfaces.
package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
	&quot;sync/atomic&quot;
)

var (
	//counter 是所有 goroutine 都要增加其值的变量
	counter int32
	//wg 用来等待程序结束
	wg sync.WaitGroup
)

// main is the entry point for the application.
func main() {
	wg.Add(2)

	//创建两个goroutine
	go incCounter(1)
	go incCounter(2)
	wg.Wait()
	fmt.Println(&quot;Final Counter&quot;, counter)
}

func incCounter(id int) {
	defer wg.Done()
	for count := 0; count &lt; 2; count++ {
		//注意这里要把counter的类型改为int32 , 不能用int
		atomic.AddInt32(&amp;counter, 1)
		//当前goroutine从线程退出, 并放回到队列
		runtime.Gosched()
	}
}
</code></pre>
<p>最终输出的结果为4</p>
</li>
<li>
<p>进行安全读写</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;sync/atomic&quot;
	&quot;time&quot;
)

var (
	//counter 是所有 goroutine 都要增加其值的变量
	shutdown int64
	//wg 用来等待程序结束
	wg sync.WaitGroup
)

// main is the entry point for the application.
func main() {
	wg.Add(2)

	//创建两个goroutine
	go doWork(&quot;A&quot;)
	go doWork(&quot;B&quot;)
	//给定goroutine执行时间
	time.Sleep(1 * time.Second)

	//该停止工作了, 安全的去设置shutdown标志
	fmt.Println(&quot;Shutdown Now&quot;)
	atomic.StoreInt64(&amp;shutdown, 1)
	wg.Wait()
}

func doWork(name string) {
	defer wg.Done()
	for {
		fmt.Printf(&quot;Doing %s Work\n&quot;, name)
		time.Sleep(250 * time.Millisecond)

		if atomic.LoadInt64(&amp;shutdown) == 1 {
			fmt.Printf(&quot;Shutting %s Down\n&quot;, name)
			break
		}
	}
}
/*
Doing B Work
Doing A Work
Doing B Work
Doing A Work
Doing A Work
Doing B Work
Doing B Work
Doing A Work
Shutdown Now
Shutting B Down
Shutting A Down
*/
</code></pre>
<p>如果StoreInt64 和 LoadInt64同时调用, 那么原子函数会将这些调用相互同步, 保证操作安全</p>
</li>
</ul>
</li>
<li>
<h4 id="互斥锁">互斥锁</h4>
<pre><code class="language-go">// Sample program to show how embedded types work with interfaces.
package main

import (
	&quot;fmt&quot;
	&quot;runtime&quot;
	&quot;sync&quot;
)

var (
	//counter 是所有 goroutine 都要增加其值的变量
	counter int
	//wg 用来等待程序结束
	wg    sync.WaitGroup
	mutex sync.Mutex
)

// main is the entry point for the application.
func main() {
	wg.Add(2)

	//创建两个goroutine
	go incCounter(1)
	go incCounter(2)
	wg.Wait()
	fmt.Println(&quot;Final Counter&quot;, counter)
}

func incCounter(id int) {
	defer wg.Done()
	for count := 0; count &lt; 2; count++ {
		mutex.Lock()

		//捕获counter的值
		value := counter

		//当前goroutine从线程退出, 并放回到队列
		runtime.Gosched()
		value++
		counter = value

		mutex.Unlock()
	}
}

</code></pre>
<p>最终结果是4, 正确, 因为锁将临界区给锁了起来</p>
</li>
</ol>
<h3 id="通道">通道</h3>
<ol>
<li>
<p>无缓冲通道模拟接力跑</p>
<pre><code class="language-go">// This sample program demonstrates how to use an unbuffered
// channel to simulate a relay race between four goroutines.
package main

import (
	&quot;fmt&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

// main is the entry point for all Go programs.
func main() {
	// Create an unbuffered channel.
	baton := make(chan int)

	// Add a count of one for the last runner.
	wg.Add(1)

	// First runner to his mark.
	go Runner(baton)

	// Start the race.
	baton &lt;- 1

	// Wait for the race to finish.
	wg.Wait()
}

// Runner simulates a person running in the relay race.
func Runner(baton chan int) {
	var newRunner int

	// Wait to receive the baton.
	runner := &lt;-baton

	// Start running around the track.
	fmt.Printf(&quot;Runner %d Running With Baton\n&quot;, runner)

	// New runner to the line.
	if runner != 4 {
		newRunner = runner + 1
		fmt.Printf(&quot;Runner %d To The Line\n&quot;, newRunner)
		go Runner(baton)
	}

	// Running around the track.
	time.Sleep(100 * time.Millisecond)

	// Is the race over.
	if runner == 4 {
		fmt.Printf(&quot;Runner %d Finished, Race Over\n&quot;, runner)
		wg.Done()
		return
	}

	// Exchange the baton for the next runner.
	fmt.Printf(&quot;Runner %d Exchange With Runner %d\n&quot;,
		runner,
		newRunner)

	baton &lt;- newRunner
}
/*
Runner 1 Running With Baton
Runner 2 To The Line
Runner 1 Exchange With Runner 2
Runner 2 Running With Baton
Runner 3 To The Line       
Runner 2 Exchange With Runner 3
Runner 3 Running With Baton
Runner 4 To The Line       
Runner 3 Exchange With Runner 4
Runner 4 Running With Baton
Runner 4 Finished, Race Over
*/
</code></pre>
</li>
<li>
<p>有缓冲通道模拟接收完成工作</p>
<pre><code class="language-go">// This sample program demonstrates how to use a buffered
// channel to work on multiple tasks with a predefined number
// of goroutines.
package main

import (
	&quot;fmt&quot;
	&quot;math/rand&quot;
	&quot;sync&quot;
	&quot;time&quot;
)

const (
	numberGoroutines = 4  // Number of goroutines to use.
	taskLoad         = 10 // Amount of work to process.
)

// wg is used to wait for the program to finish.
var wg sync.WaitGroup

// init is called to initialize the package by the
// Go runtime prior to any other code being executed.
func init() {
	// Seed the random number generator.
	rand.Seed(time.Now().Unix())
}

// main is the entry point for all Go programs.
func main() {
	// Create a buffered channel to manage the task load.
	tasks := make(chan string, taskLoad)

	// Launch goroutines to handle the work.
	wg.Add(numberGoroutines)
	for gr := 1; gr &lt;= numberGoroutines; gr++ {
		go worker(tasks, gr)
	}

	// Add a bunch of work to get done.
	for post := 1; post &lt;= taskLoad; post++ {
		tasks &lt;- fmt.Sprintf(&quot;Task : %d&quot;, post)
	}

	// Close the channel so the goroutines will quit
	// when all the work is done.
	close(tasks)

	// Wait for all the work to get done.
	wg.Wait()
}

// worker is launched as a goroutine to process work from
// the buffered channel.
func worker(tasks chan string, worker int) {
	// Report that we just returned.
	defer wg.Done()

	for {
		// Wait for work to be assigned.
		task, ok := &lt;-tasks
		if !ok {
			// This means the channel is empty and closed.
			fmt.Printf(&quot;Worker: %d : Shutting Down\n&quot;, worker)
			return
		}

		// Display we are starting the work.
		fmt.Printf(&quot;Worker: %d : Started %s\n&quot;, worker, task)

		// Randomly wait to simulate work time.
		sleep := rand.Int63n(100)
		time.Sleep(time.Duration(sleep) * time.Millisecond)

		// Display we finished the work.
		fmt.Printf(&quot;Worker: %d : Completed %s\n&quot;, worker, task)
	}
}
/*
Worker: 4 : Started Task : 2
Worker: 2 : Started Task : 1
Worker: 3 : Started Task : 3
Worker: 1 : Started Task : 4
Worker: 2 : Completed Task : 1
Worker: 2 : Started Task : 5
Worker: 1 : Completed Task : 4
Worker: 1 : Started Task : 6  
Worker: 3 : Completed Task : 3
Worker: 3 : Started Task : 7  
Worker: 4 : Completed Task : 2
Worker: 4 : Started Task : 8
Worker: 4 : Completed Task : 8
Worker: 4 : Started Task : 9  
Worker: 3 : Completed Task : 7
Worker: 3 : Started Task : 10 
Worker: 2 : Completed Task : 5
Worker: 2 : Shutting Down
Worker: 1 : Completed Task : 6
Worker: 1 : Shutting Down
Worker: 3 : Completed Task : 10
Worker: 3 : Shutting Down
Worker: 4 : Completed Task : 9
Worker: 4 : Shutting Down
*/
</code></pre>
</li>
</ol>
<h2 id="第七章--并发模型">第七章 : 并发模型</h2>
<h3 id="runner">runner</h3>
<p>直接看代码, 要点都写在注释里面了</p>
<p>Runner:</p>
<pre><code class="language-go">package runner

import (
	&quot;errors&quot;
	&quot;os&quot;
	&quot;os/signal&quot;
	&quot;time&quot;
)

// Runner 在给定的超时时间内执行一组任务 并且在操作系统发送中断信号的时结束这些任务
type Runner struct {
    /*
    	用三个通道来辅助管理程序的生命周期
    */
	// interrupt 通道报告从操作系统发送的信号
	interrupt chan os.Signal

	// complete 通道报告处理任务已经完成, 并返回相应的错误类型
	complete chan error

	// timeout 报告处理任务已经超时
	timeout &lt;-chan time.Time

	//tasks 持有一组以索引顺序依次执行的函数
	tasks []func(int)
}

var (
	// ErrTimeout 超时时返回
	ErrTimeout = errors.New(&quot;received timeout&quot;)
	// ErrInterrupt 接收到操作系统的事件时返回
	ErrInterrupt = errors.New(&quot;received interrupt&quot;)
)

// New 返回一个新的准备使用的Runner
func New(d time.Duration) *Runner {
	return &amp;Runner{
        //有缓冲的通道, 容量为1, 保证通道至少能接收一个来自语言运行时的os.Signal值, 确保运行时发送的那个事件不会被阻塞
		interrupt: make(chan os.Signal, 1),
		complete:  make(chan error),
        //d 为time.Duration, 在设定的时间到了之后会返回一个time.Time值被timeout通道接收
		timeout:   time.After(d),
	}
}

// Add 将一个任务附加到Runner上, 这个任务是一个接收一个int类型的ID作为参数的函数
func (r *Runner) Add(tasks ...func(int)) {
	r.tasks = append(r.tasks, tasks...)
}

// Start 执行所有任务并且监视通道事件
func (r *Runner) Start() error {
	// 我们希望接受所有中断信号
	signal.Notify(r.interrupt, os.Interrupt)
	// 用不同的goroutine执行不同的任务
	go func() {
		r.complete &lt;- r.run()
	}()
    //上面的程序在异步的跑的时候, 外部在检测程序是否正常运行结束或超时或中断了
	select {
	// 程序处理完的时候
	case err := &lt;-r.complete:
		return err
	// 程序超时 这里是全部task运行时间
	case &lt;-r.timeout:
		return ErrTimeout
	}
}

func (r *Runner) run() error {
	for id, task := range r.tasks {
		// 检测操作系统的中断信号
		if r.gotInterrupt() {
			return ErrInterrupt
		}
		//执行已注册的函数
		task(id)
	}
    return nil
}

// gotInterrupt 验证是否接受到了中断信号
func (r *Runner) gotInterrupt() bool {
	select {
	case &lt;-r.interrupt:
		//当中断事件被触发时, 停止接受后续的任何信号
		signal.Stop(r.interrupt)
		return true
    //在run里面每个函数开始处理的时候若没有中断信号, 那就把这个任务执行完
	default:
		return false
	}

}
</code></pre>
<p>main :</p>
<pre><code class="language-go">package main

import (
	&quot;interview/runner&quot;
	&quot;log&quot;
	&quot;os&quot;
	&quot;time&quot;
)

const timeout = 3 * time.Second

func main() {
	log.Println(&quot;Starting work.&quot;)
	r := runner.New(timeout)
	r.Add(createTask(), createTask(), createTask())

	if err := r.Start(); err != nil {
		switch err {
		case runner.ErrTimeout:
			log.Println(&quot;Terminating due to time out&quot;)
			os.Exit(1)
		case runner.ErrInterrupt:
			log.Println(&quot;Terminating due to interrupt.&quot;)
			os.Exit(2)
		}
	}
	log.Println(&quot;Process ended.&quot;)
}

func createTask() func(int) {
	return func(id int) {
		log.Printf(&quot;Processor - Task #%d.&quot;, id)
		//time.Duration 是time里面定一个的一个类型 type Duration int64
		time.Sleep(time.Duration(id) * time.Second)
	}
}
</code></pre>
<pre><code class="language-go">/*
output:
	1. timeout = 3 * time.Second
		2022/04/02 16:26:12 Starting work.
        2022/04/02 16:26:12 Processor - Task #0.
        2022/04/02 16:26:12 Processor - Task #1.
        2022/04/02 16:26:13 Processor - Task #2.
        2022/04/02 16:26:15 Terminating due to time out
	2. timeout = 6 * timeSecond
		2022/04/02 16:29:08 Starting work.
        2022/04/02 16:29:08 Processor - Task #0.
        2022/04/02 16:29:08 Processor - Task #1.
        2022/04/02 16:29:09 Processor - Task #2.
        2022/04/02 16:29:11 Process ended.
*/
</code></pre>
<h3 id="pool">pool</h3>
<h3 id="work">work</h3>

</article>


      

      



      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">Next</span>
        <a href="https://zyooo.github.io/golangdairy/go_day1/" class="block">Go_Day1</a>
      
    </div>
  </div>


      



    </div>
    
      <div class="col-span-2">
        
        
          <div
  class="
    bg-primary-bg
   prose sticky top-16 z-10 hidden px-6 py-4 lg:block"
>
  <h3>On This Page</h3>
</div>
<div
  class="sticky-toc  hidden px-6 pb-6 lg:block"
>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#go语言实战">Go语言实战</a>
      <ul>
        <li><a href="#第一章go语言介绍">第一章：Go语言介绍</a></li>
        <li><a href="#第三章打包和go工具">第三章：打包和Go工具</a></li>
        <li><a href="#第四章-数组切片和映射">第四章: 数组、切片和映射</a>
          <ul>
            <li><a href="#数组">数组</a></li>
            <li><a href="#切片">切片</a></li>
            <li><a href="#映射map">映射map</a></li>
          </ul>
        </li>
        <li><a href="#第五章-go语言的类型系统">第五章: Go语言的类型系统</a>
          <ul>
            <li><a href="#接口">接口</a></li>
            <li><a href="#嵌入类型">嵌入类型</a></li>
          </ul>
        </li>
        <li><a href="#第六章-并发">第六章: 并发</a>
          <ul>
            <li><a href="#并发与并行">并发与并行</a></li>
            <li><a href="#goroutine">goroutine</a></li>
            <li><a href="#竞争状态">竞争状态</a></li>
            <li><a href="#锁">锁</a>
              <ul>
                <li><a href="#原子函数">原子函数</a></li>
                <li><a href="#互斥锁">互斥锁</a></li>
              </ul>
            </li>
            <li><a href="#通道">通道</a></li>
          </ul>
        </li>
        <li><a href="#第七章--并发模型">第七章 : 并发模型</a>
          <ul>
            <li><a href="#runner">runner</a></li>
            <li><a href="#pool">pool</a></li>
            <li><a href="#work">work</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
</div>
<script>
  window.addEventListener("DOMContentLoaded", () => {
    enableStickyToc();
  });
</script>

        
      </div>
    

    
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.initHighlightingOnLoad();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2021 <a href="https://www.wangchucheng.com/">WANG Chucheng</a> and <a href="https://www.ruiqima.com/">MA Ruiqi</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
    </footer>
  </body>
</html>
