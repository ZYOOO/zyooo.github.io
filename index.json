[{"categories":[""],"content":"一级 啦啦 啦啦啦 ;aaaaa 啊啊啊啊 ","date":"2022-03-28","objectID":"/note/test/:0:0","tags":[""],"title":"Test","uri":"/note/test/"},{"categories":[""],"content":"二级 ","date":"2022-03-28","objectID":"/note/test/:1:0","tags":[""],"title":"Test","uri":"/note/test/"},{"categories":[""],"content":"三级 四级 五级 六级 ","date":"2022-03-28","objectID":"/note/test/:1:1","tags":[""],"title":"Test","uri":"/note/test/"},{"categories":null,"content":"1601.最多可达成的换楼请求目的 hard 对于每个选择, 都有选或者不选两个操作, delta数组记录每栋楼的员工变化量, 以及变量cnt记录被选择的请求数量, 如果选择当前请求, delta[x]值减1, delta[y]加1, 不选择则不做操作, 枚举完了之后判断delta中所有值是否为0, 并且根据cnt和res大小更新答案. func maximumRequests(n int, requests [][]int) int { res := 0 delta := make([]int,n) cnt,res,zero,l := 0,0,n,len(requests) var dfs func(pos int) dfs = func(pos int){ if pos == l { if zero == n \u0026\u0026 cnt \u003e res { res = cnt } return } //not dfs(pos+1) //chose z := zero cnt++ x,y := requests[pos][0],requests[pos][1] //减少之前 if delta[x] == 0 { zero-- } delta[x]-- //减少之后 if delta[x] == 0 { zero++ } if delta[y] == 0 { zero-- } delta[y]++ if delta[y] == 0 { zero++ } dfs(pos+1) delta[x]++ delta[y]-- cnt-- zero = z } dfs(0) return res } ","date":"2022-02-28","objectID":"/leetcodedairy/20220228/:0:0","tags":null,"title":"2022-02-28","uri":"/leetcodedairy/20220228/"},{"categories":null,"content":"这道题用O(N^2)的解法会超时, 所以要想办法降低时间复杂度, 所以使用二分法, 但是这里二分的不是time数组, 而是时间, 而时间的区间如何取定呢, 先把time升序排序, 然后最短的可能是1s, 最长的时间可能是time[0] * totoalTrips, 所以就可以采用二分法了 func minimumTime(time []int, totalTrips int) int64 { sort.Ints(time) var left,right int64 = 1,int64(time[0]*totalTrips) n := len(time) for left \u003c right { var tmp int64= 0 mid := left + (right-left)\u003e\u003e1 for i := 0; i \u003c n \u0026\u0026 int64(time[i]) \u003c= mid; i++ { tmp += mid/int64(time[i]) } //左搜索, 右收缩 if tmp \u003e= int64(totalTrips) { right = mid } else { left = mid+1 } } return left } ","date":"2022-02-27","objectID":"/leetcodedairy/20220227/:0:0","tags":null,"title":"第282场周赛T3","uri":"/leetcodedairy/20220227/"},{"categories":null,"content":"开始是直接遍历的方法得到数字, 后来想着如果是严格按照一个形式的话, 那么 一个复数中只会出现一个 ‘+’ 并且将虚部和实部分割, 可以利用这个去直接得到abcd, 不过不知道底层代码, 估计速度也是差不多的 代码: 100% 100% func complexNumberMultiply(num1 string, num2 string) string { a,b := parse(num1) c,d := parse(num2) return fmt.Sprintf(\"%v+%vi\",(a*c-b*d),(a*d+b*c)) } func parse (num string)(int,int){ a,b := 0,0 i,fa,fb := 0,1,1 flag := true n := len(num) if num[0] == '-' { fa = -1 i = 1 } for ;i \u003c n; i++{ if num[i] \u003e= '0' \u0026\u0026 num[i] \u003c= '9'{ if flag { a = a*10 + int(num[i] - '0') } else { b = b*10 + int(num[i] - '0') } } if num[i] == '+' { flag = false } else if num[i] == '-' { flag = false fb = -1 } } return a*fa,b*fb } 代码:100% 94% func complexNumberMultiply(num1 string, num2 string) string { //注意消除最后一位i a1 := strings.Split(num1[:len(num1)-1],\"+\") a2 := strings.Split(num2[:len(num2)-1],\"+\") a,_ := strconv.ParseInt(a1[0],10,32) b,_ := strconv.ParseInt(a1[1],10,32) c,_ := strconv.ParseInt(a2[0],10,32) d,_ := strconv.ParseInt(a2[1],10,32) return fmt.Sprintf(\"%v+%vi\",(a*c-b*d),(a*d+b*c)) } ","date":"2022-02-24","objectID":"/leetcodedairy/20220224/:0:0","tags":null,"title":"2022-02-24","uri":"/leetcodedairy/20220224/"},{"categories":null,"content":"1001.网格照明 hard 2022.02.08 数据规模太大了, 原本想着硬模拟的后来还是放弃了 打算用map去存储行列和两个对角的情况, 但是又不知道怎么去表示同一条对角 官方题解: func gridIllumination(n int, lamps, queries [][]int) []int { type pair struct{ x, y int } points := map[pair]bool{} row := map[int]int{} col := map[int]int{} diagonal := map[int]int{} antiDiagonal := map[int]int{} for _, lamp := range lamps { r, c := lamp[0], lamp[1] p := pair{r, c} if points[p] { continue } points[p] = true row[r]++ col[c]++ //用这个来表示哪条对角, 妙啊 diagonal[r-c]++ antiDiagonal[r+c]++ } ans := make([]int, len(queries)) for i, query := range queries { r, c := query[0], query[1] if row[r] \u003e 0 || col[c] \u003e 0 || diagonal[r-c] \u003e 0 || antiDiagonal[r+c] \u003e 0 { ans[i] = 1 } for x := r - 1; x \u003c= r+1; x++ { for y := c - 1; y \u003c= c+1; y++ { if x \u003c 0 || y \u003c 0 || x \u003e= n || y \u003e= n || !points[pair{x, y}] { continue } delete(points, pair{x, y}) row[x]-- col[y]-- diagonal[x-y]-- antiDiagonal[x+y]-- } } } return ans } 学习点: 对于在map里面存储一个坐标, 可以定义一个结构体 type pair struct{ x int y int } pairs := map[pair]bool{} //加了花括号就不用make了? 如何表示在同一条对角线 p := pair{r,c} if points[p] {//这里不管有没有添加,可以这样判断, 应该是有默认值的 continue } points[p] = true row[r]++ col[c]++ //用这个来表示哪条对角, 妙啊 diagonal[r-c]++ antiDiagonal[r+c]++ ","date":"2022-02-20","objectID":"/leetcodedairy/20220208/:0:0","tags":null,"title":"2022-02-08","uri":"/leetcodedairy/20220208/"},{"categories":null,"content":"田忌赛马,打不过就送人头 代码逻辑 n := len(nums1) sort.Ints(nums1) //田忌的马 sort.Ints(nums2) //齐王的马 for i := n-1; i \u003e= 0; i-- { if nums1[i] \u003e nums2[i] { //比得过跟他比 } else { //比不过,换的垫底的来送人头 } } int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.length; // 给 nums2 降序排序 PriorityQueue\u003cint[]\u003e maxpq = new PriorityQueue\u003c\u003e( (int[] pair1, int[] pair2) -\u003e { return pair2[1] - pair1[1]; //比较方式 } ); for (int i = 0; i \u003c n; i++) { maxpq.offer(new int[]{i, nums2[i]}); } // 给 nums1 升序排序 Arrays.sort(nums1); // nums1[left] 是最小值，nums1[right] 是最大值 int left = 0, right = n - 1; int[] res = new int[n]; while (!maxpq.isEmpty()) { int[] pair = maxpq.poll(); // maxval 是 nums2 中的最大值，i 是对应索引 int i = pair[0], maxval = pair[1]; if (maxval \u003c nums1[right]) { // 如果 nums1[right] 能胜过 maxval，那就自己上 res[i] = nums1[right]; right--; } else { // 否则用最小值混一下，养精蓄锐 res[i] = nums1[left]; left++; } } return res; } go的话不用优先队列,用二维数组的排序试一试 ","date":"2022-01-09","objectID":"/leetcodedairy/20220109/:0:0","tags":null,"title":"2022-01-09","uri":"/leetcodedairy/20220109/"},{"categories":null,"content":"二维数组排序 sort.Slice(arr, func(i, j int) bool { return arr[i][1] \u003e arr[j][1] //按照每行的第一个元素排序,\u003e 降序, \u003c 升序 }) func advantageCount(nums1, nums2 []int) []int { sort.Ints(nums1) var arr [][]int res := make([]int, len(nums1)) left, right := 0, len(nums1)-1 for i, v := range nums2 { tmp := []int{i, v} arr = append(arr, tmp) } sort.Slice(arr, func(i, j int) bool { return arr[i][1] \u003e arr[j][1] //按照每行的第一个元素排序 }) for i := 0; i \u003c len(nums1); i++ { if arr[i][1] \u003c nums1[right] { res[arr[i][0]] = nums1[right] right-- } else { res[arr[i][0]] = nums1[left] left++ } } return res } 接雨水问题 思路: water[i] = min( l_max , r_max) - height[i] 暴力: 每次求出两边最大值 O(N^2) O(1) int trap(vector\u003cint\u003e\u0026 height) { int n = height.size(); int res = 0; for (int i = 1; i \u003c n - 1; i++) { int l_max = 0, r_max = 0; // 找右边最高的柱子 for (int j = i; j \u003c n; j++) r_max = max(r_max, height[j]); // 找左边最高的柱子 for (int j = i; j \u003e= 0; j--) l_max = max(l_max, height[j]); // 如果自己就是最高的话， // l_max == r_max == height[i] res += min(l_max, r_max) - height[i]; } return res; } 备忘录 : 提前求出l_max, r_max 数组 O(N) O(N) int trap(vector\u003cint\u003e\u0026 height) { if (height.empty()) return 0; int n = height.size(); int res = 0; // 数组充当备忘录 vector\u003cint\u003e l_max(n), r_max(n); // 初始化 base case l_max[0] = height[0]; r_max[n - 1] = height[n - 1]; // 从左向右计算 l_max for (int i = 1; i \u003c n; i++) l_max[i] = max(height[i], l_max[i - 1]); // 从右向左计算 r_max for (int i = n - 2; i \u003e= 0; i--) r_max[i] = max(height[i], r_max[i + 1]); // 计算答案 for (int i = 1; i \u003c n - 1; i++) res += min(l_max[i], r_max[i]) - height[i]; return res; } 双指针: O(N) O(1) func trap(height []int) int { if len(height) == 0 { return 0 } n := len(height) res, left, right := 0, 0, n-1 lMax, rMax := height[0], height[n-1] for left \u003c= right { lMax = int(math.Max(float64(lMax),float64(height[left]))) rMax = int(math.Max(float64(rMax),float64(height[right]))) if lMax \u003c rMax { res += lMax - height[left] left++ } else { res += rMax - height[right] right-- } } return res } r_max是不是右边最大的并没所谓,只要 l_max \u003c r_max 就行了 最长回文子串 核心思想: 从中间开始向两边扩散来判断回文串, 为了解决abba偶数问题,传入两个参数l,r for 0 \u003c= i \u003c len(s){ 找到以 s[i] / s[i]和s[i+1](要防止数组越界) 为中心的回文串 更新答案 } func longestPalindrome(s string) string { res := \"\" for i := 0; i \u003c len(s); i++ { //以s[i]为中心的最长回文子串 s1 := palindrome(s, i, i) //以s[i]和s[i+1]为中心得最长回文子串 s2 := palindrome(s, i, i+1) //res = longest(res,s1,s2) if len(res) \u003c len(s1) { res = s1 } if len(res) \u003c len(s2) { res = s2 } } return res } func palindrome(s string, l, r int) string { //防止索引越界 for l \u003e= 0 \u0026\u0026 r \u003c len(s) \u0026\u0026 s[l] == s[r] { l-- r++ } sb := []byte(s) //返回以s[l] 和 s[r]为中心的最长回文串 //返回的索引应是l+1 ~ r-1 因为切片是到x - 1,所以这里到r 不包含r return string(sb[l+1 : r]) } 也可以用动态规划,但是动态规划空间复杂度O(N^2) 这个只需要O(1) ","date":"2022-01-09","objectID":"/leetcodedairy/20220109/:1:0","tags":null,"title":"2022-01-09","uri":"/leetcodedairy/20220109/"},{"categories":null,"content":"滑动窗口问题 int left = 0, right = 0 for right \u003c len(s) { //增大窗口 window.add(s[right]) right++ for window needs shrink{ window.remove(s[left]) left++ } } O(N) ","date":"2022-01-09","objectID":"/leetcodedairy/20220108/:0:0","tags":null,"title":"2022-01-09","uri":"/leetcodedairy/20220108/"},{"categories":null,"content":"框架 //滑动窗口算法框架 func slidingWindow(s, t string) { need := make(map[string]int) window := make(map[string]int) for _,c := range t{ need[string(c)]++ } left,right,valid := 0,0,0 for right \u003c len(s) { //c是将移入窗口的字符 c := s[right] //右移窗口 right++ //对窗口内数据的一系列更新 ... //debug输出的位置 fmt.Printf(\"window: [%d,%d)\\n\",left,right) //判断左侧窗口是否要收缩 for window needs shrink{ //d 是将移出窗口的字符 d := s[left] //左移窗口 left++ //进行窗口内数据的一系列更新 ... } } } 76.Minimum Window Substring func minWindow(s, t string) string { need := make(map[string]int) window := make(map[string]int) for _, c := range t { need[string(c)]++ } left, right, valid := 0, 0, 0 start, length := 0, len(s)+1 for right \u003c len(s) { //c是将移入窗口的字符 c := string(s[right]) //右移窗口 right++ //对窗口内数据的一系列更新 if _, ok := need[c]; ok { window[c]++ if window[c] == need[c] { valid++ } } //判断左侧窗口是否要收缩 for valid == len(need) { if right-left \u003c length { start = left length = right - left } //d 是将移出窗口的字符 d := string(s[left]) //左移窗口 left++ //进行窗口内数据的一系列更新 if _, ok := need[d]; ok { if window[d] == need[d] { valid-- } window[d]-- } } } if length == len(s)+1 { return \"\" } return s[start : start+length] } ","date":"2022-01-09","objectID":"/leetcodedairy/20220108/:1:0","tags":null,"title":"2022-01-09","uri":"/leetcodedairy/20220108/"},{"categories":null,"content":"二分搜索 //搜素左侧边界 func left_bound(nums []int, target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left \u003c right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩右侧边界 right = mid }else if nums[mid] \u003c target{ left = mid + 1 }else if nums[mid] \u003e target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 2 //搜索右侧边界 func right_bound(nums int[], target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left \u003c right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩左侧边界 left = mid + 1 }else if nums[mid] \u003c target{ left = mid + 1 }else if nums[mid] \u003e target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 4 技巧: 从题目中抽象出一个自变量x , 一个关于x的函数f(x), 以及一个目标值 target , 同时还要满足以下条件 : 1. f(x)必须是在x上的单调函数 2. 题目是让你计算满足约束条件f(x) == target 时的x 的值 例如上例: func f(x int, nums []int) int { return nums[x] } 题目就相当于求 满足 f(x) == targeet 的x的最小值是多少 框架: //函数f是关于自变量x的单调函数 func f(x int){ //... } //主函数,在f(x) == target 的约束下求x的最值 func solution (nums []int, target int) int { if len(nums) == 0 { return -1 //看题目 } left,right := ..., ... + 1 for left \u003c right { mid := left + (right - left) / 2 if f(mid) == target { //题目是求左边界还是右边界? } else if f(mid) \u003c target { //怎么让f(mid) 大一点? } else if f(mid) \u003e target { //怎么让f(mid) 小一点? } } return left } 1011.在D天内送达包裹的能力 分析: 用二分法方法, 找出x , f(x) 还有 target(题目) , target一般和f(x)的值作比较, 题目要找谁的边界值, 谁就是x 所以此题 target 为 days , x为承载能力, f(x) 为承载能力对应的天数. 单调递减, 且求最低运载能力 向左收缩, 收缩右边 func f(weights []int, x int) int { day := 0 weight := 0 for _, w := range weights { weight += w if weight \u003e x { weight = w day++ } } return day + 1 } func shipWithinDays(weights []int, days int) int { //承载能力为x, f(x)为天数, days为target //left为weights里面的最大值,如果小于最大值那么这一批货永远运不了, right为一次送完的承载量 left, right := 0, 1 for _, x := range weights { if x \u003e left { left = x } right += x } for left \u003c right { mid := left + (right-left)/2 //函数单调递减 if f(weights, mid) \u003c= days { //最低运载,左搜索,右收缩 right = mid } else { left = mid + 1 } } return left } 875.爱吃香蕉的珂珂 同上分析: 速度为x 对应的时间为f(x) H为target ,最小速度 向左搜索, 右侧收缩 func f(piles []int, x int) int { hours := 0 for i := 0; i \u003c len(piles); i++ { hours += piles[i] / x if piles[i]%x \u003e 0 { hours++ } } return hours } func minEatingSpeed(piles []int, h int) int { //二分搜索速度,target是H,左侧搜索,收缩右侧 left,right := 1,1000000000 + 1 for left \u003c right { mid := left + (right - left) / 2 if f(piles,mid) \u003c= h { //收缩左侧 right = mid } else { left = mid + 1 } } return left } ","date":"2022-01-09","objectID":"/leetcodedairy/20220107/:1:0","tags":null,"title":"2022-01-09","uri":"/leetcodedairy/20220107/"},{"categories":null,"content":"15.三数之和 穷举,确定了第一个数字之后, 剩下两个数字就是 target = target - nums[i] 的twoSum问题 func twoSumTarget2(nums []int, start, target int) [][]int { var ans [][]int //sort.Ints(nums) lo, hi := start, len(nums)-1 for lo \u003c hi { sum := nums[lo] + nums[hi] left, right := nums[lo], nums[hi] if sum \u003c target { for lo \u003c hi \u0026\u0026 nums[lo] == left { //跳过重复项,保证答案唯一 lo++ } } else if sum \u003e target { for lo \u003c hi \u0026\u0026 nums[hi] == right { hi-- } } else { ans = append(ans, []int{nums[lo], nums[hi]}) for lo \u003c hi \u0026\u0026 nums[lo] == left { lo++ } for lo \u003c hi \u0026\u0026 nums[hi] == right { hi-- } } } return ans } func threeSumTarget(nums []int, target int) [][]int { sort.Ints(nums) var ans [][]int for i := 0; i \u003c len(nums); i++ { tuples := twoSumTarget2(nums, i+1, target-nums[i]) //存在二元组,就加上nums[i]成为三元组 for j := 0; j \u003c len(tuples); j++ { tuples[j] = append(tuples[j], nums[i]) ans = append(ans, tuples[j]) } //跳过第一个数字重复的情况,避免出现重复结果 for i \u003c len(nums)-1 \u0026\u0026 nums[i] == nums[i+1] { i++ } } return ans } 71.简化路径 func simplifyPath(path string) string { stack := []string{} for _, name := range strings.Split(path, \"/\") { if name == \"..\" { if len(stack) \u003e 0 { stack = stack[:len(stack)-1] } } else if name != \"\" \u0026\u0026 name != \".\" { stack = append(stack, name) } } return \"/\" + strings.Join(stack, \"/\") } ","date":"2022-01-06","objectID":"/leetcodedairy/20220106/:0:0","tags":null,"title":"2022-01-06","uri":"/leetcodedairy/20220106/"},{"categories":null,"content":"1576.替换所有的问号 func modifyString(s string) string { data := []byte(s) for i := 0; i \u003c len(data); i++ { if data[i] == '?' { for b := byte('a'); b \u003c= 'c'; b++ { if !(i \u003e 0 \u0026\u0026 data[i-1] == b || i \u003c len(data)-1 \u0026\u0026 data[i+1] == b) { data[i] = b break } } } } return string(data[:]) } 一个点在于, 实际上只需要遍历三个字母,就可以找到适合的答案, 还有就是里面那个 if 语句很好的解决了i=0 和 i = length-1的问题. []byte和string之间的转化方式 res := []byte( s ) string(res) 剑指offer II 027.回文联表 递归判断回文链表 var left *ListNode func isPalindrome(head *ListNode) bool { left = head return traverse(head) } func traverse(right *ListNode) bool { if right == nil { return true } res := traverse(right.Next) res = res \u0026\u0026 (right.Val == left.Val) left = left.Next return res } 优化空间复杂度: 先找到链表的中点 伪代码 slow,fast := head,head for fast != nil \u0026\u0026 fast.next != nil{ slow = slow.Next fast = fast.Next.Next } 长度为奇数的时候slow为中点 长度为偶数的时候slow为靠后的那个 如果fast没有指向nil,说明链表长度为奇数,slow还要向前一步 if fast != nil{ //说明fast.Next == nil slow = slow.Next } 然后从slow开始反转后面的链表, 然后开始比较回文串, 整合一下 func isPalindrome(head *ListNode)bool{ slow,fast := head,head for fast != nil \u0026\u0026 fast.Next != nil{ slow = slow.Next fast = fast.Next.Next } if fast != nil{ slow = slow.Next } left := head right := reverse(slow) for right != nil{ if left.Val != right.Val{ return false } left = left.Next right = right.Next } return true } func reverse(head *ListNode) *ListNode{//让指针掉个头 var pre *ListNode = nil cur := head for cur != nil{ next := cur.Next cur.Next = pre pre = cur cur = next } return pre } 时间复杂度O(n),空间复杂度O(1),只改变了链表的指向 ","date":"2022-01-05","objectID":"/leetcodedairy/20220105/:0:0","tags":null,"title":"2022-01-05","uri":"/leetcodedairy/20220105/"},{"categories":null,"content":"19.删除链表的倒数第N个节点 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := new(ListNode) dummy.Next = head x := findFromEnd(dummy,n+1) //找到倒数第n+1个然后将倒数第n个删除 x.Next = x.Next.Next return dummy.Next } func findFromEnd(head *ListNode,k int) *ListNode{ p1,p2 := head,head for i := 0; i \u003c k; i++{ p1 = p1.Next } for p1 != nil{ p1 = p1.Next p2 = p2.Next } return p2 } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:1:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"知识点：找到链表的中点 利用快慢指针，一个步长为1，一个步长为2，此方法在链表长度为偶数的时候，返回的是靠后的那个节点(因为其实最后一个节点的Next为nil也当做一个结点，链表长度相当于+1了) func middleNode(head *ListNode) *ListNode{ slow,fast := head,head for fast != nil \u0026\u0026 fast.Next != nil{ slow = slow.Next fast = fast.Next.Next } return slow } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:2:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"知识点: 判断链表是否包含环 快慢指针追击,如果fast最终和slow相遇,则说明链表有环,如果fast最后为nil,则说明链表无环. func hasCycle(head *ListNode) bool{ slow,fast := head,head for fast != nil \u0026\u0026 fast.Next != nil{ slow = slow.Next fast = fast.Next.Next if(slow == fast){ return true } } return false } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:3:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"知识点: 链表含环进阶版: 环的起点 func detectCycle(head *ListNode) *ListNode{ slow,fast := head,head for fast != nil \u0026\u0026 fast.Next != nil{ slow = slow.Next fast = fast.Next.Next if fast == slow{ slow = head for fast != slow { slow = slow.Next fast = fast.Next } return fast } } return nil } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:4:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"知识点: 两个链表是否相交 A ,B长度不一致,相差A-B,但是A+B = B+A,逆过来连接可以把A,B之间的差给补齐,保证了C对齐(如果存在) 如果不存在就nil就相当于c1,解决乐正确返回nil的问题 func getIntersectionNode(headA,headB *ListNode) *ListNode{ p1,p2 := headA,headB for p1 != p2{ if p1 == nil{ //此时如果有c的话就到了c的末尾了,开始到B p1 = headB }else{ p1 = p1.Next } if p2 == nil{ p2 = headA }else{ p2 = p2.Next } } return p1 } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:5:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"160.相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 用上面的相交解决O(1),可以一用map去存储,但是时间复杂度为O(m+n) ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:6:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"26.删除排序数组中的重复项 func removeDuplicates(nums []int) int { if len(nums) == 0{ return 0 } slow,fast := 0,0 for fast \u003c len(nums){ if nums[slow] != nums[fast]{ slow ++ nums[slow] = nums[fast] } fast++ } return slow+1 } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:7:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"27.移除元素 func removeElement(nums []int, val int) int { slow, fast := 0, 0 for fast \u003c len(nums) { if nums[fast] != val { nums[slow] = nums[fast] slow++ } fast++ } return slow } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:8:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"283.移动零 [1,0,2,0,4] -\u003e [1,2,4,0,0] func removeElement(nums []int, val int) int { slow, fast := 0, 0 for fast \u003c len(nums) { if nums[fast] != val { nums[slow] = nums[fast] slow++ } fast++ } return slow } func moveZeroes(nums []int){ p := removeElement(nums,0) for ; p \u003c len(nums) ; p++{ nums[p] = 0 } } ","date":"2022-01-04","objectID":"/leetcodedairy/20220104/:9:0","tags":null,"title":"2022-01-04","uri":"/leetcodedairy/20220104/"},{"categories":null,"content":"1185.一周中的第几天 难度简单92 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。 输入为三个整数：day、month 和 year，分别表示日、月、年。 您返回的结果必须是这几个值中的一个 {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}。 用了一个公式： W = (D + 2 * M + 3 * (M + 1) \\ 5 + Y + Y \\ 4 - Y \\ 100 + Y \\ 400+1) Mod 7 但是一月和二月要用13,14表示。 class Solution { public String dayOfTheWeek(int day, int month, int year) { String[] days = {\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\"}; if(month == 1){ month = 13; year--; }else if(month == 2){ month = 14; year --; } //W = (D + 2 * M + 3 * (M + 1) \\ 5 + Y + Y \\ 4 - Y \\ 100 + Y \\ 400+1) Mod 7 return days[(day + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400 + 1) % 7]; } } 23.合并k个有序链表 难点在于如何快速得到k个节点中的最小节点 优先级队列（二叉堆），将链表中的节点放入一个最小堆，每次获得k个结点中最小的节点 go里面没有内置的优先队列api，所以要自己写（用最小堆可以实现，重写heap里的方法去实现） 或者使用分治的方法去实现 最小堆方法实现： package main import \"container/heap\" type ListNode struct { Val int Next *ListNode } type minHeap []*ListNode func (h minHeap) Len() int { return len(h) } func (h minHeap) Less(i, j int) bool { return h[i].Val \u003c h[j].Val } func (h minHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *minHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) //.后跟括号，是对象类型转换，只有结构对象才能执行类型动态转换/查询 } func (h *minHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] //old[n-1]是最小元素，堆顶？查查看最小堆概念 *h = old[0 : n-1] //切片删除old[n-1] endIndex-1即 0~n-2 return x } func mergeKLists(lists []*ListNode) *ListNode { h := new(minHeap) //创建一个最小堆 for i := 0; i \u003c len(lists); i++ { if lists[i] != nil { //k个链表的头结点加入最小堆中，注意加入的方法 heap.Push(h,xxx) heap.Push(h, lists[i]) } } dummyHead := new(ListNode) pre := dummyHead for h.Len() \u003e 0 { //获取最小堆的堆定元素，即最小的 tmp := heap.Pop(h).(*ListNode) if tmp.Next != nil { //被取出的节点还有next的话就加入最小堆 heap.Push(h, tmp.Next) } pre.Next = tmp pre = pre.Next } return dummyHead.Next } 分治方法： func mergeKLists(lists []*ListNode) *ListNode { length := len(lists) if length \u003c 1 { return nil } if length == 1 { return lists[0] } num := length / 2 left := mergeKLists(lists[:num]) //一直分割然后合并返回，最后一次返回的就是完整的链表 right := mergeKLists(lists[num:]) return mergeTwoLists1(left, right) } func mergeTwoLists1(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u003c l2.Val { l1.Next = mergeTwoLists1(l1.Next, l2) return l1 } l2.Next = mergeTwoLists1(l1, l2.Next) return l2 } 傻瓜方法遍历k-1遍 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { dummy := new(ListNode) p := dummy.Next for i := 0; i \u003c len(lists); i++{ p = mergeTwoLists(p,lists[i]) } return p } func mergeTwoLists(l1, l2 *ListNode) *ListNode { dummy := new(ListNode) p := dummy p1, p2 := l1, l2 for p1 != nil \u0026\u0026 p2 != nil { if p1.Val \u003e p2.Val { p.Next = p2 p2 = p2.Next } else { p.Next = p1 p1 = p1.Next } p = p.Next } if p1 == nil { p.Next = p2 } else { p.Next = p1 } return dummy.Next } 知识点： . 后跟括号，是对象类型转换，只有结构对象才能执行类型动态转换/查询 Pop中为什么删除最后一个 x := old[n-1] //old[n-1]是最小元素，堆顶？查查看最小堆概念 *h = old[0 : n-1] //切片删除old[n-1] endIndex-1即 0~n-2 源码： Pop() interface{} // remove and return element Len() - 1. 可能是源码把他放到了最后 func Pop(h Interface) interface{} { n := h.Len() - 1 h.Swap(0, n) down(h, 0, n) return h.Pop() } 从源码可以看出，实际的弹出步骤是将第一个元素与最后一个元素进行互换（所以要将最后一个删了，因为那是第一个弹出的，然后对一个元素进行下沉，最后移除并返回最后一个元素 ","date":"2022-01-03","objectID":"/leetcodedairy/20220103/:0:0","tags":null,"title":"2022-01-03","uri":"/leetcodedairy/20220103/"},{"categories":null,"content":"Hello, golang! ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:0:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"Hello world package main //有main函数的话这里一定要有main import \"fmt\" //一个项目一个main函数，和c一样，与java不同 func main() { fmt.Println(\"Hello,World!\") fmt.Println(\"Hello golang\") } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:1:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"标识符 老规矩，不能数字开头、不能关键字、不能含运算符。 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:2:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"关键字 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:3:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"空格 变量的声明必须使用空格隔开 var age int //注意：代码中有未使用变量的话，将无法通过编译 //可用以下方法 age = age _ = age ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:4:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"格式化字符串 Go中使用 fmt.Sprintf 格式化字符串并赋值给新串： package main import ( \"fmt\" ) func main() { // %d 表示整型数字，%s 表示字符串 var stockcode=123 var enddate=\"2021-12-30\" var url=\"Code=%d\u0026endDate=%s\" var target_url=fmt.Sprintf(url,stockcode,enddate) fmt.Println(target_url) //输出结果为 Code=123\u0026endDate=2021-12-30 } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:5:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"数据类型 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:6:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"布尔类型 var b bool = true ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:6:1","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"数字类型 int、float32、float64，支持复数， 中位运算采用补码 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:6:2","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"字符串类型 字符串用单个字节连接起来的，字节使用UTF-8编码 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:6:3","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"派生类型 指针（Pointer）、数组、结构化类型、函数类型 Channel类型、切片类型、interface类型、Map类型 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:6:4","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"数字类型 uint8、uint16、uint32、uint64、int8、int16、int32、int64、float32、float64、complex64（32位实数和虚数）、complex128、byte（类似于uint8）、rune（类似于int32）、uint（32或64位）、uintptr（无符号整型，用于存放指针） ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:7:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"语言变量 var a string = \"string\" var b,c int = 1,2 var d int //默认0 var e bool //默认false var f string //默认为\"\" //一下几种为nil: var a *int var a []int var a map[string] int var a chan int var a func(string) int var a error //error is interface //还可以根据值自行判断 var a = true //默认为bool //intVal := 1 相等于 var intVal int intVal = 1 多变量声明 //类型相同多个变量, 非全局变量 var vname1, vname2, vname3 type vname1, vname2, vname3 = v1, v2, v3 var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断 vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误 // 这种因式分解关键字的写法一般用于声明全局变量 var ( vname1 v_type1 vname2 v_type2 ) 空白标识符 _ ,实际上是一个只写变量 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:8:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"常量 const LENGTH int = 10 用作枚举 const( ​ Unknown = 0 ​ Female = 1 ​ Male = 2 ) 常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过； package main import \"unsafe\" const ( a = \"abc\" b = len(a) c = unsafe.Sizeof(a) ) func main(){ println(a, b, c) } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:9:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"iota iota，特殊常量，可以认为是一个可以被编译器修改的常量。 iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。 iota 可以被用作枚举值 const ( a = iota b = iota c = iota ) const ( a = iota b c ) package main import \"fmt\" func main() { const ( a = iota //0 b //1 c //2 d = \"ha\" //独立值，iota += 1 e //\"ha\" iota += 1 f = 100 //iota +=1 g //100 iota +=1 h = iota //7,恢复计数 i //8 ) fmt.Println(a,b,c,d,e,f,g,h,i) } //结果 0 1 2 ha ha 100 100 7 8 package main import \"fmt\" const ( i=1\u003c\u003ciota j=3\u003c\u003ciota k l ) func main() { fmt.Println(\"i=\",i) fmt.Println(\"j=\",j) fmt.Println(\"k=\",k) fmt.Println(\"l=\",l) } //i=1 j=6 k=12 l=24 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:9:1","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"运算符 基本一样， \u0026取地址 ，* 指针变量 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:10:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"条件语句 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:11:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"if语句 不用括号，并且可以在if中声明变量； if var a int; a - 50 \u003c b{ } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:11:1","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"switch语句 case 后面不用beak；不会自动执行下一条语句，fallthrough关键字会强制执行下一条case的语句 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:11:2","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"select语句 select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。 select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的 select { case communication clause : statement(s); case communication clause : statement(s); /* 你可以定义任意数量的 case */ default : /* 可选 */ statement(s); } /* 以下描述了 select 语句的语法： 每个 case 都必须是一个通信 所有 channel 表达式都会被求值 所有被发送的表达式都会被求值 如果任意某个通信可以进行，它就执行，其他被忽略。 如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 否则： 如果有 default 子句，则执行该语句。 如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。 */ ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:11:3","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"循环语句 和 C 语言的 for 一样： for init; condition; post { } 和 C 的 while 一样： for condition { } 和 C 的 for(;;) 一样： for { } for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下： for key, value := range oldMap { newMap[key] = value } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:12:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"函数 func swap(x, y string) (string, string) { return y, x } 如果函数返回值声明了变量，那return后面可以不加东西 func add(x,y int) (sum int){ sum = x + y; return } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:13:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"初始化数组 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} //数组长度不确定时，可以用...代替数组的长度，编译器会自行推断。 //如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小。 var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0} balance := [5]float32{1:2.0,3:7.0} ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:14:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"结构体 结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下： type struct_variable_type struct { member definition member definition ... member definition } variable_name := structure_variable_type {value1, value2…valuen} 或 variable_name := structure_variable_type { key1: value1, key2: value2…, keyn: valuen} ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:15:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"切片slice ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:16:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"概念 切片可看作一种对数组的包装形式，他的包装数组称为该切片的底层数组。反过来讲，切片是针对其底层数组中某个连续片段的描述。切片的长度是可变的，并不是类型的一部分，只要元素类型相同，两个切片的类型就是相同的，一个切片类型的零值总是nil（空指针），此零值的长度和容量都为0。 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:16:1","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"定义切片 var identifier []type 切片不需要说明长度 或使用 make() 函数来创建切片: var slice1 []type = make([]type, len) //也可以简写为 slice1 := make([]type, len) //也可以指定容量，其中 capacity 为可选参数。 make([]T, length, capacity) ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:16:2","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"切片初始化 s :=[] int {1,2,3 } 直接初始化切片，[] 表示是切片类型，{1,2,3} 初始化值依次是 1,2,3，其 cap=len=3。 s := arr[:] 初始化切片 s，是数组 arr 的引用。 s := arr[startIndex:endIndex] 将 arr 中从下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片。 s := arr[startIndex:] 默认 endIndex 时将表示一直到arr的最后一个元素。 s := arr[:endIndex] 默认 startIndex 时将表示从 arr 的第一个元素开始。 s1 := s[startIndex:endIndex] 通过切片 s 初始化切片 s1。 s := make([]int,len,cap) 通过内置函数 make() 初始化切片s，[]int 标识为其元素类型为 int 的切片。 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:16:3","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"len() and cap() functions 切片是可索引的，并且可以由 len() 方法获取长度。 切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。 以下为具体实例： 实例 package main import \"fmt\" func main() { var numbers = make([]int,3,5) printSlice(numbers) } func printSlice(x []int){ fmt.Printf(\"len=%d cap=%d slice=%v\\n\",len(x),cap(x),x) } 以上实例运行输出结果为: len=3 cap=5 slice=[0 0 0] 一个切片在未初始化之前默认为 nil，长度为 0，实例如下 package main import \"fmt\" func main() { s := [7]int{1, 2, 3, 4, 5, 6, 7} var numbers = s[3:5] printSlice(numbers) } func printSlice(x []int) { fmt.Printf(\"len=%d,cap=%d,slice=%v\", len(x), cap(x), x) } //输出结果 len=2,cap=4,slice=[4 5] ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:16:4","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"范围range 用于for循环中迭代数组、切片、通道、或map，在数组和切片中返回索引和索引对应的值，在mao返回key-value值 package main import \"fmt\" func main() { //这是我们使用range去求一个slice的和。使用数组跟这个很类似 nums := []int{2, 3, 4} sum := 0 for _, num := range nums { sum += num } fmt.Println(\"sum:\", sum) //在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符\"_\"省略了。有时侯我们确实需要知道它的索引。 for i, num := range nums { if num == 3 { fmt.Println(\"index:\", i) } } //range也可以用在map的键值对上。 kvs := map[string]string{\"a\": \"apple\", \"b\": \"banana\"} for k, v := range kvs { fmt.Printf(\"%s -\u003e %s\\n\", k, v) } //range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。 for i, c := range \"go\" { fmt.Println(i, c) } } sum: 9 index: 1 a -\u003e apple b -\u003e banana 0 103 1 111 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:17:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"map package main import \"fmt\" func main() { var countryCapitalMap map[string]string /*创建集合 */ countryCapitalMap = make(map[string]string) /* map插入key - value对,各个国家对应的首都 */ countryCapitalMap [ \"France\" ] = \"巴黎\" countryCapitalMap [ \"Italy\" ] = \"罗马\" countryCapitalMap [ \"Japan\" ] = \"东京\" countryCapitalMap [ \"India \" ] = \"新德里\" /*使用键输出地图值 */ for country := range countryCapitalMap { fmt.Println(country, \"首都是\", countryCapitalMap [country]) } /*查看元素在集合中是否存在 */ capital, ok := countryCapitalMap [ \"American\" ] /*如果确定是真实的,则存在,否则不存在 */ /*fmt.Println(capital) */ /*fmt.Println(ok) */ if (ok) { fmt.Println(\"American 的首都是\", capital) } else { fmt.Println(\"American 的首都不存在\") } } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:18:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"接口 package main import ( \"fmt\" ) type Phone interface { call() } type NokiaPhone struct { } func (nokiaPhone NokiaPhone) call() { fmt.Println(\"I am Nokia, I can call you!\") } type IPhone struct { } func (iPhone IPhone) call() { fmt.Println(\"I am iPhone, I can call you!\") } func main() { var phone Phone phone = new(NokiaPhone) phone.call() phone = new(IPhone) phone.call() } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:19:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"错误 package main import ( \"fmt\" ) // 定义一个 DivideError 结构 type DivideError struct { dividee int divider int } // 实现 `error` 接口 func (de *DivideError) Error() string { strFormat := ` Cannot proceed, the divider is zero. dividee: %d divider: 0 ` return fmt.Sprintf(strFormat, de.dividee) } // 定义 `int` 类型除法运算的函数 func Divide(varDividee int, varDivider int) (result int, errorMsg string) { if varDivider == 0 { dData := DivideError{ dividee: varDividee, divider: varDivider, } errorMsg = dData.Error() return } else { return varDividee / varDivider, \"\" } } func main() { // 正常情况 if result, errorMsg := Divide(100, 10); errorMsg == \"\" { fmt.Println(\"100/10 = \", result) } // 当除数为零的时候会返回错误信息 if _, errorMsg := Divide(100, 0); errorMsg != \"\" { fmt.Println(\"errorMsg is: \", errorMsg) } } 100/10 = 10 errorMsg is: Cannot proceed, the divider is zero. dividee: 100 divider: 0 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:20:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"并发 Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。 goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。 goroutine 语法格式： go 函数名 (参数列表） package main import ( \"fmt\" \"time\" ) func main() { go say(\"world\") say(\"hello\") } func say(s string) { for i := 0; i \u003c 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } world hello hello world world hello hello world world hello ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:21:0","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"通道channel 通道（channel）是用来传递数据的一个数据结构。 通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 \u003c- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。 ch \u003c- v // 把 v 发送到通道 ch v := \u003c-ch // 从 ch 接收数据 // 并把值赋给 v 声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建： ch := make(chan int) 注意：默认情况下，通道是不带缓冲区的。发送端发送数据，同时必须有接收端相应的接收数据。 以下实例通过两个 goroutine 来计算数字之和，在 goroutine 完成计算后，它会计算两个结果的和： package main import \"fmt\" func main() { s := []int{7, 2, 7, 2, 1, 3, 5, 6, -1, 1} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u003c-c, \u003c-c fmt.Println(x, y, x+y) } func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u003c- sum // sum发送到通道c } 14 19 33 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:21:1","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"通道缓冲区 第二个参数为缓存区大小 ch := make(chan int,100) 带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。 不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。 注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。 package main import \"fmt\" func main() { // 这里我们定义了一个可以存储整数类型的带缓冲通道 // 缓冲区大小为2 ch := make(chan int, 2) // 因为 ch 是带缓冲的通道，我们可以同时发送两个数据 // 而不用立刻需要去同步读取数据 ch \u003c- 1 ch \u003c- 2 // 获取这两个数据 fmt.Println(\u003c-ch) fmt.Println(\u003c-ch) } ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:21:2","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"遍历通道与关闭通道 range来实现遍历读到的数据 v,ok := \u003c-ch 如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。 package main import ( \"fmt\" ) func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u003c n; i++ { c \u003c- x x, y = y, x+y } close(c) } func main() { c := make(chan int, 10) go fibonacci(cap(c), c) // range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个 // 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据 // 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不 // 会结束，从而在接收第 11 个数据的时候就阻塞了。 for i := range c { fmt.Println(i) } } 0 1 1 2 3 5 8 13 21 34 ","date":"2021-12-30","objectID":"/golangdairy/go_day1/:21:3","tags":null,"title":"Go_Day1","uri":"/golangdairy/go_day1/"},{"categories":null,"content":"318.最大单词长度乘积 给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-of-word-lengths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处. 本来以为简简单单，结果发现看漏了题目中不含有公共字母的两个单词。然后感觉难度暴增，最后也是成功写出了屎一般的代码，11%+6%。看了题解之后学到了新的东西，思路其实差不多，最优的时间复杂度也是要O(n²)，但是在比较是否出现公共字母的时候，不想用int[26]去表示一个字符串出现过的字母，那样子空间和时间都花费很多，最后看了题解发现可以用掩码去解决，就是用一个int的低26位表示，效果和数组一样，而且比较只需要\u0026运算就能算出，快太多了。 官方题解是将mask（掩码）作为map的key，length作为map的val，然后再去双重遍历keySet得出最大的答案。按照这个思路做了之后，还是不够快，最后去看高速度的题解，才发现有更快的方法！真是厉害，直接不用map，用于words长度相等的一个int[]去存放掩码，然后通过对应的数组下标可以直接得到words[i].length()空间上更加节省了，同时因为是有顺序去二重遍历的，所以一重循环i\u003cwords.length-1，而二重循环的ｊ的开始是ｉ＋１，因为在在前面ｉ的遍历中已经和当前ｊ匹配过了，所以无需再匹配了。 class Solution { public int maxProduct(String[] words) { int ans = 0; //words中每个string对应的掩码 int[] masks = new int[words.length]; for(int i = 0; i \u003c words.length; i++){ for(char c : words[i].toCharArray()) masks[i] |= 1\u003c\u003c(c-'a'); } //二重遍历 for(int i = 0; i \u003c words.length-1; i++){ for(int j = i+1; j \u003c words.length; j++){ //字符串无公共字母 if((masks[i] \u0026 masks[j]) == 0) ans = Math.max(ans,words[i].length() * words[j].length()); } } return ans; } } ","date":"2021-11-17","objectID":"/leetcodedairy/20211117/:1:0","tags":null,"title":"2021-11-17","uri":"/leetcodedairy/20211117/"},{"categories":null,"content":"319.灯泡开关 @脑筋急转弯 初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。 找出并返回 n 轮后有多少个亮着的灯泡。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bulb-switcher 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 最开始模拟了整个过程,结果测试例子给个99999999,直接超出内存限制,感觉事情并不简单. 题解: class Solution { public int bulbSwitch(int n) { return (int) Math.sqrt(n); } } /* 影响第x位灯泡的因素是他的约数 例如6, 约数为1,2,3,6 第一轮即点亮所有,2是关闭,3是点亮,最后6会关闭,所以有偶数个约数的位的灯泡最后都是关闭 所以只有奇数个约数的位最后才会被点亮,即为完全平方数 例如4,约数为1,2,4 n个数中,完全平方数的数量刚好为sqrt(n)向下取整 例如n=9,其中1,4,9为平方数,数量为sqrt(9) = 3 1\u003c= x² \u003c= n 1\u003c= x \u003c= sqrt(n) */ ","date":"2021-11-15","objectID":"/leetcodedairy/20211115/:0:1","tags":null,"title":"Day6-2021-11-15","uri":"/leetcodedairy/20211115/"},{"categories":null,"content":"修改Tomcat的默认端口和启动项目 ","date":"2021-11-10","objectID":"/bugs/tomcat/:1:0","tags":null,"title":"Tomcat","uri":"/bugs/tomcat/"},{"categories":null,"content":"修改默认端口 1.首先查看80端口是否被占用 netstat -lntp | grep 80 2.进入tomcat安装目录下的conf文件夹修改server.xml文件 将端口修改为80 但是这个时候输入netstat -lntp | grep 80 查看发现只监听了 127.0.0.1:80 没有打开:::80,也就是0.0.0.0:80 导致外部无法访问80端口,最后重启了云服务器之后在查看发现可以了. ","date":"2021-11-10","objectID":"/bugs/tomcat/:1:1","tags":null,"title":"Tomcat","uri":"/bugs/tomcat/"},{"categories":null,"content":"修改默认启动项目 在host下面添加 context的内容,docBase就是项目路径名称,默认的绝对路径是上面配置的name和appBase ","date":"2021-11-10","objectID":"/bugs/tomcat/:1:2","tags":null,"title":"Tomcat","uri":"/bugs/tomcat/"},{"categories":null,"content":"重塑矩阵 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reshape-the-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 原本想的就是先判断面积是否相等,然后将速度按照rc去放入,但是赶着吃饭没想明白用取余的具体操作,就直接暴力了. class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { if(r*c != mat.length*mat[0].length){ return mat; } int[] arr = new int[r*c]; int index = 0; for(int i = 0; i \u003c mat.length; i++){ for(int j = 0; j \u003c mat[0].length; j++){ arr[index++] = mat[i][j]; } } int[][] ans = new int[r][c]; index = 0; for(int i = 0; i \u003c r; i++){ for(int j = 0; j \u003c c; j++){ ans[i][j] = arr[index++]; } } return ans; } } 官方题解 class Solution { public int[][] matrixReshape(int[][] nums, int r, int c) { int m = nums.length; int n = nums[0].length; if (m * n != r * c) { return nums; } int[][] ans = new int[r][c]; for (int x = 0; x \u003c m * n; ++x) { ans[x / c][x % c] = nums[x / n][x % n]; } return ans; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/reshape-the-matrix/solution/zhong-su-ju-zhen-by-leetcode-solution-gt0g/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-11-05","objectID":"/leetcodedairy/20211105/:1:0","tags":null,"title":"2021-11-05","uri":"/leetcodedairy/20211105/"},{"categories":null,"content":"杨辉三角 感觉写的又长又臭啊 class Solution { public List\u003cList\u003cInteger\u003e\u003e generate(int numRows) { List\u003cList\u003cInteger\u003e\u003e ans = new ArrayList\u003cList\u003cInteger\u003e\u003e(); for(int i = 0; i \u003c numRows; i++){ List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); list.add(1); if(i == 0){ ans.add(list); continue; }else if(i == 1){ list.add(1); }else{ for(int j = 1; j \u003c i; j++){ list.add(ans.get(i-1).get(j) + ans.get(i-1).get(j-1)); } list.add(1); } ans.add(list); } return ans; } } 官方题解,这个++j 就是差距,学到了. class Solution { public List\u003cList\u003cInteger\u003e\u003e generate(int numRows) { List\u003cList\u003cInteger\u003e\u003e ret = new ArrayList\u003cList\u003cInteger\u003e\u003e(); for (int i = 0; i \u003c numRows; ++i) { List\u003cInteger\u003e row = new ArrayList\u003cInteger\u003e(); for (int j = 0; j \u003c= i; ++j) { if (j == 0 || j == i) { row.add(1); } else { row.add(ret.get(i - 1).get(j - 1) + ret.get(i - 1).get(j)); } } ret.add(row); } return ret; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/pascals-triangle/solution/yang-hui-san-jiao-by-leetcode-solution-lew9/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-11-05","objectID":"/leetcodedairy/20211105/:2:0","tags":null,"title":"2021-11-05","uri":"/leetcodedairy/20211105/"},{"categories":null,"content":"两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 我的思路是先把一个数组存入hashmap中,用值来当key,value为这个数组中这个数字的出现次数,然后遍历第二个数组,当map中有这个值存在而且value大于0,就将这个值加入到list中,最后再将list转化为int[],但是不能直接转换成int[],只能直接转换成Integer[],所以就采用了遍历赋值的方法. class Solution { public int[] intersect(int[] nums1, int[] nums2) { Map\u003cInteger,Integer\u003e map = new HashMap\u003c\u003e(); List\u003cInteger\u003e list = new ArrayList\u003c\u003e(); for (int x : nums1) { if(map.containsKey(x)){ map.put(x,map.get(x)+1); }else{ map.put(x,1); } } for(int x : nums2){ if(map.get(x) != null \u0026\u0026 map.get(x) \u003e 0){ list.add(x); map.replace(x,map.get(x)-1); } } int[] ans = new int[list.size()]; for(int i=0; i \u003c list.size(); i++){ ans[i] = list.get(i); } return ans; } } 官方题解思路差不多,但是为了降低空间复杂度，首先遍历较短的数组并在哈希表中记录每个数字以及对应出现的次数，然后遍历较长的数组得到交集。 class Solution { public int[] intersect(int[] nums1, int[] nums2) { if (nums1.length \u003e nums2.length) { return intersect(nums2, nums1); } Map\u003cInteger, Integer\u003e map = new HashMap\u003cInteger, Integer\u003e(); for (int num : nums1) { int count = map.getOrDefault(num, 0) + 1; map.put(num, count); } int[] intersection = new int[nums1.length]; int index = 0; for (int num : nums2) { int count = map.getOrDefault(num, 0); if (count \u003e 0) { intersection[index++] = num; count--; if (count \u003e 0) { map.put(num, count); } else { map.remove(num); } } } return Arrays.copyOfRange(intersection, 0, index); } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/solution/liang-ge-shu-zu-de-jiao-ji-ii-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-11-04","objectID":"/leetcodedairy/20211104/:1:0","tags":null,"title":"2021-11-04","uri":"/leetcodedairy/20211104/"},{"categories":null,"content":"买卖股票最佳时机 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 自己的思路: 建立一个新的数组,将明天减去今天的利润存入,然后通过贪心算法求出最大利润,解法如之前做过的最大连续子序和题目一样,时间复杂度O(n),空间复杂度O(n-1). class Solution { public int maxProfit(int[] prices) { int[] profit = new int [prices.length]; int maxSum = 0; int currentSum = 0; int lastSum = 0; for(int i = 0 ; i \u003c prices.length-1; i++){ profit[i] = prices[i+1]-prices[i]; } for(int i = 0; i \u003c profit.length; i++){ int num = profit[i]; if(lastSum \u003e 0){ currentSum = num + lastSum; }else{ currentSum = num; } lastSum = currentSum; maxSum = (currentSum \u003e maxSum) ? currentSum : maxSum; } return maxSum; } } 官方题解还是牛逼,一次遍历,动态的取一个最低价格,动态的假装卖出并且记录最大利润,最后返回最大利润即可. 时间复杂度：O(n)，只需要遍历一次。 空间复杂度：O(1)，只使用了常数个变量。 public class Solution { public int maxProfit(int prices[]) { int minprice = Integer.MAX_VALUE; int maxprofit = 0; for (int i = 0; i \u003c prices.length; i++) { if (prices[i] \u003c minprice) { minprice = prices[i]; } else if (prices[i] - minprice \u003e maxprofit) { maxprofit = prices[i] - minprice; } } return maxprofit; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-leetcode-/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-11-04","objectID":"/leetcodedairy/20211104/:2:0","tags":null,"title":"2021-11-04","uri":"/leetcodedairy/20211104/"},{"categories":null,"content":"合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 使用双指针比较两数组尾,即排序后的最大数值,倒序放入nums1中,如果两个数组中的一个已经遍历完,则剩余的都为另一数组剩余的. class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { //从尾部开始比谁大再放入tail指向的nums1中值 int p1 = m-1; int p2 = n-1; int tail = m+n-1; while(p2 \u003e= 0 || p1 \u003e= 0){ //m个已经全部放完,剩下的全部放nums2 if(p1 == -1){ nums1[tail--] = nums2[p2--]; }else if(p2 == -1){ nums1[tail--] = nums1[p1--]; }else if(nums2[p2] \u003e= nums1[p1]){ nums1[tail--] = nums2[p2--]; }else{ nums1[tail--] = nums1[p1--]; } } } } ","date":"2021-11-03","objectID":"/leetcodedairy/20211103/:1:0","tags":null,"title":"2021-11-03","uri":"/leetcodedairy/20211103/"},{"categories":null,"content":"两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/two-sum 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 将数组遍历放进哈希表中,数组值作为key,数组索引作为value,一边添加一边去判断,当前添加的数组的值,是否已经有另一半答案已经添加了,即是否存在 目标值减去当前值的差已经在表中,有的话得出value 即数组的下标,输出答案 class Solution { public int[] twoSum(int[] nums, int target) { Map\u003cInteger,Integer\u003e map = new HashMap\u003c\u003e(); for(int i=0; i\u003cnums.length; i++){ if(map.containsKey(target - nums[i])){ return new int [] {i,map.get(target - nums[i])}; } map.put(nums[i],i); } return null; } } ","date":"2021-11-03","objectID":"/leetcodedairy/20211103/:2:0","tags":null,"title":"2021-11-03","uri":"/leetcodedairy/20211103/"},{"categories":null,"content":"最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 用贪心算法去解决此问题,遍历数组,得到当前的值,如果lastCount小于零的话就抛弃,当前和就等于当前值,如果lastCount大于等于0的话就和当前值相加作为当前和,lastCount等于当前和,当前和和最大和比较,得出最大和,遍历完一边之后返回最大和. 时间复杂度:O(n) 空间复杂度: O(1) class Solution { public int maxSubArray(int[] nums) { int index = 0; int lastCount = 0; int maxCount = 0; for(int currentNum : nums){ int currentCount; if(index == 0){ index++; currentCount = currentNum; lastCount = currentCount; maxCount = currentCount; }else{ if(lastCount \u003c 0){ currentCount = currentNum; maxCount = (maxCount \u003e currentCount) ? maxCount : currentCount; lastCount = currentCount; }else{ currentCount = currentNum + lastCount; maxCount = (maxCount \u003e currentCount) ? maxCount : currentCount; lastCount = currentCount; } } } return maxCount; } } 自己写的又长又臭,看看题解的动态规划 class Solution { public int maxSubArray(int[] nums) { int pre = 0, maxAns = nums[0]; for (int x : nums) { pre = Math.max(pre + x, x); maxAns = Math.max(maxAns, pre); } return maxAns; } } 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-10-31","objectID":"/leetcodedairy/20211031/:1:0","tags":null,"title":"2021-10-31","uri":"/leetcodedairy/20211031/"},{"categories":null,"content":"存在重复元素 给定一个整数数组，判断是否存在重复元素。 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。 比较简单利用哈希表的add去判断是否有重复添加 class Solution { public boolean containsDuplicate(int[] nums) { Set\u003cInteger\u003e set = new HashSet\u003cInteger\u003e(); for(int num : nums){ if(!set.add(num)){ return true; } } return false; } } ","date":"2021-10-31","objectID":"/leetcodedairy/20211031/:2:0","tags":null,"title":"2021-10-31","uri":"/leetcodedairy/20211031/"},{"categories":null,"content":"Day 1 Success means different things for different people, some may equate it with fame, some with wealth and still some with accomplishments. For me, it means fulfilling one’s dreams. Whatever your dreams are, you have a goal and then focus all your attention on it. Dreams bring you hope and happiness. In the process of struggling for it, you cry, sweat, complain or even purse,but the joy of harvesting makes you forget all the pains and troubles you have gone through.So an old proverb says that the sweetest fruit is one that has undergone the bitterest ordeal. There are several keys to success. First,your goal must be practical and practicable.If you set your goal too high, chance are that you will never attain it.Next,you have to make a plan for doing it. You can take some steps to realize it.Since the process is quite though., you need to be diligent,patient and persevering. Even if you meet with some difficulties or frustrations, just take them in your stride.You can always tell yourself that there is nothing insurmountable.With this will and determination, success is sure to wait for you at the end of the tunnel! ","date":"2021-10-20","objectID":"/note/oralenglish/:1:0","tags":null,"title":"OralEnglish","uri":"/note/oralenglish/"},{"categories":null,"content":"Nginx 1.课程目标 目标1：掌握Nginx的安装 目标2：掌握Nginx的静态网站部署 目标3：理解Nginx的反向代理与负载均衡，能够配置反向代理与负载均衡 2.Nginx的安装与启动 ","date":"2021-10-17","objectID":"/javadairy/nginx/:0:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"2.1什么是Nginx Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。 Nginx 应用场景： 1、http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 ","date":"2021-10-17","objectID":"/javadairy/nginx/:1:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"2.2 Nginx在Linux下的安装 重新准备一台虚拟机作为服务器。比如IP地址为192.168.177.129 ","date":"2021-10-17","objectID":"/javadairy/nginx/:2:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"2.2.1环境准备 （1）需要安装 gcc 的环境【此步省略】 yum install gcc-c++ （2）第三方的开发包。 PCRE PCRE(Perl Compatible Regular Expressions)是一个 Perl 库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库。 yum install -y pcre pcre-devel 注：pcre-devel 是使用 pcre 开发的一个二次开发库。nginx 也需要此库。 zlib zlib 库提供了很多种压缩和解压缩的方式，nginx 使用 zlib 对 http 包的内容进行 gzip，所以需要在 linux 上安装 zlib 库。 yum install -y zlib zlib-devel OpenSSL OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在 ssl 协议上传输 http），所以需要在 linux安装 openssl 库。 yum install -y openssl openssl-devel ","date":"2021-10-17","objectID":"/javadairy/nginx/:2:1","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"2.2.2 Nginx下载 官方网站下载 nginx：http://nginx.org/ 我们课程中使用的版本是 1.8.0 版本。 ","date":"2021-10-17","objectID":"/javadairy/nginx/:2:2","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"2.2.3 Nginx安装 第一步：把 nginx 的源码包nginx-1.8.0.tar.gz上传到 linux 系统 第二步：解压缩 tar zxvf nginx-1.8.0.tar.gz 第三步：进入nginx-1.8.0目录 使用 configure 命令创建一 makeFile 文件。 ./configure --prefix=/usr/local/nginx --pid-path=/var/run/nginx/nginx.pid --lock-path=/var/lock/nginx.lock --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --with-http_gzip_static_module --http-client-body-temp-path=/var/temp/nginx/client --http-proxy-temp-path=/var/temp/nginx/proxy --http-fastcgi-temp-path=/var/temp/nginx/fastcgi --http-uwsgi-temp-path=/var/temp/nginx/uwsgi --http-scgi-temp-path=/var/temp/nginx/scgi 执行后可以看到Makefile文件 第四步：编译 make 第五步：安装 make install ","date":"2021-10-17","objectID":"/javadairy/nginx/:2:3","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"2.3 Nginx启动与访问 注意：启动nginx 之前，上边将临时文件目录指定为/var/temp/nginx/client， 需要在/var 下创建此 目录 mkdir /var/temp/nginx/client -p 进入到Nginx目录下的sbin目录 cd /usr/local/ngiux/sbin 输入命令启动Nginx ./nginx 启动后查看进程 ps aux|grep nginx 地址栏输入虚拟机的IP即可访问（默认为80端口） 关闭 nginx： ./nginx -s stop 或者 ./nginx -s quit 重启 nginx： 1、先关闭后启动。 2、刷新配置文件： ./nginx -s reload 3.Nginx静态网站部署 ","date":"2021-10-17","objectID":"/javadairy/nginx/:3:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"3.1 静态网站的部署 将/资料/静态页面/index目录下的所有内容 上传到服务器的/usr/local/nginx/html下即可访问 ","date":"2021-10-17","objectID":"/javadairy/nginx/:4:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"3.2 配置虚拟主机 虚拟主机，也叫“网站空间”，就是把一台运行在互联网上的物理服务器划分成多个“虚拟”服务器。虚拟主机技术极大的促进了网络技术的应用和普及。同时虚拟主机的租用服务也成了网络时代的一种新型经济形式。 ","date":"2021-10-17","objectID":"/javadairy/nginx/:5:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"3.2.1 端口绑定 （1）上传静态网站： 将/资料/静态页面/index目录上传至 /usr/local/nginx/index下 将/资料/静态页面/regist目录上传至 /usr/local/nginx/regist下 （2）修改Nginx 的配置文件：/usr/local/nginx/conf/nginx.conf server { listen 81; # 监听的端口 server_name localhost; # 域名或ip location / { # 访问路径配置 root index;# 根目录 index index.html index.htm; # 默认首页 } error_page 500 502 503 504 /50x.html; # 错误页面 location = /50x.html { root html; } } server { listen 82; # 监听的端口 server_name localhost; # 域名或ip location / { # 访问路径配置 root regist;# 根目录 index regist.html; # 默认首页 } error_page 500 502 503 504 /50x.html; # 错误页面 location = /50x.html { root html; } } （3）访问测试： 地址栏输入http://192.168.177.129/:81 可以看到首页面 地址栏输入http://192.168.177.129/:82 可以看到注册页面 ","date":"2021-10-17","objectID":"/javadairy/nginx/:5:1","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"3.2.2 域名绑定 什么是域名： 域名（[Domain Name](https://baike.baidu.com/item/Domain Name)），是由一串用“点”分隔的字符组成的Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置，地理上的域名，指代有行政自主权的一个地方区域）。域名是一个IP地址上有“面具” 。域名的目的是便于记忆和沟通的一组服务器的地址（网站，电子邮件，FTP等）。域名作为力所能及难忘的互联网参与者的名称。域名按域名系统（DNS）的规则流程组成。在DNS中注册的任何名称都是域名。域名用于各种网络环境和应用程序特定的命名和寻址目的。通常，域名表示互联网协议（IP）资源，例如用于访问因特网的个人计算机，托管网站的服务器计算机，或网站本身或通过因特网传送的任何其他服务。世界上第一个注册的域名是在1985年1月注册的。 *域名级别：* *（1）顶级域名* 顶级域名又分为两类： 一是国家顶级域名（national top-level domainnames，简称nTLDs），200多个国家都按照ISO3166国家代码分配了顶级域名，例如中国是cn，美国是us，日本是jp等； 二是国际顶级域名（international top-level domain names，简称iTDs），例如表示工商企业的 .Com .Top，表示网络提供商的.net，表示非盈利组织的.org，表示教育的.edu，以及没有限制的中性域名如.xyz等。大多数域名争议都发生在com的顶级域名下，因为多数公司上网的目的都是为了赢利。但因为自2014年以来新顶级域名的发展，域名争议案件数量增长幅度越来越大[5] 。为加强域名管理，解决域名资源的紧张，Internet协会、Internet分址机构及世界知识产权组织（WIPO）等国际组织经过广泛协商， 在原来三个国际通用顶级域名：（com）的基础上，新增加了7个国际通用顶级域名：firm（公司企业）、store（销售公司或企业）、Web（突出WWW活动的单位）、arts（突出文化、娱乐活动的单位）、rec (突出消遣、娱乐活动的单位）、info(提供信息服务的单位）、nom(个人），并在世界范围内选择新的注册机构来受理域名注册申请。 例如：baidu.com *（2）二级域名* 二级域名是指顶级域名之下的域名，在国际顶级域名下，它是指域名注册人的网上名称，例如 ibm，yahoo，microsoft等；在国家顶级域名下，它是表示注册企业类别的符号，例如.top，com，edu，gov，net等。 中国在国际互联网络信息中心（Inter NIC） 正式注册并运行的顶级域名是CN，这也是中国的一级域名。在顶级域名之下，中国的二级域名又分为类别域名和行政区域名两类。类别域名共7个， 包括用于科研机构的ac；用于工商金融企业的com、top；用于教育机构的edu；用于政府部门的 gov；用于互联网络信息中心和运行中心的net；用于非盈利组织的org。而行政区域名有34个，分别对应于中国各省、自治区和直辖市。 例如：map.baidu.com *（3）三级域名* 三级域名用字母（ A～Z，a～z，大小写等）、数字（0～9）和连接符（－）组成， 各级域名之间用实点（.）连接，三级域名的长度不能超过20个字符。如无特殊原因，建议采用申请人的英文名（或者缩写）或者汉语拼音名 （或者缩写） 作为三级域名，以保持域名的清晰性和简洁性。 例如： item.map.baidu.com *域名与IP绑定：* 一个域名对应一个 ip 地址，一个 ip 地址可以被多个域名绑定。 本地测试可以修改 hosts 文件（C:\\Windows\\System32\\drivers\\etc） 可以配置域名和 ip 的映射关系，如果 hosts 文件中配置了域名和 ip 的对应关系，不需要走dns 服务器。 192.168.177.129 www.hmtravel.com 192.168.177.129 regist.hmtravel.com 做好域名指向后，修改nginx配置文件 server { listen 80; server_name www.hmtravel.com; location / { root cart; index cart.html; } } server { listen 80; server_name regist.hmtravel.com; location / { root search; index search.html; } } 执行以下命令，刷新配置 [root@localhost sbin]# ./nginx -s reload 测试： 地址栏输入http://www.hmtravel.com/ 地址栏输入http://regist.hmtravel.com/ *4.Nginx反向代理与负载均衡* ","date":"2021-10-17","objectID":"/javadairy/nginx/:5:2","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.1 反向代理* ","date":"2021-10-17","objectID":"/javadairy/nginx/:6:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.1.1 什么是反向代理* 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 首先我们先理解正向代理，如下图： 正向代理是针对你的客户端，而反向代理是针对服务器的，如下图 ","date":"2021-10-17","objectID":"/javadairy/nginx/:6:1","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.1.2 配置反向代理-准备工作* （1） 将travel案例部署到tomcat中（ROOT目录），上传到服务器。 （2）启动TOMCAT，输入网址http://192.168.177.129:8080 可以看到网站首页 ","date":"2021-10-17","objectID":"/javadairy/nginx/:6:2","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.1.3 配置反向代理* （1）在Nginx主机修改 Nginx配置文件 upstream tomcat-travel{ server 192.168.177.129:8080; } server { listen 80; # 监听的端口 server_name www.hmtravel.com; # 域名或ip location / { # 访问路径配置 # root index;# 根目录 proxy_pass http://tomcat-travel; index index.html index.htm; # 默认首页 }} （2）重新启动Nginx 然后用浏览器测试：http://www.hmtravel.com （此域名须配置域名指向） ","date":"2021-10-17","objectID":"/javadairy/nginx/:6:3","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.2 负载均衡* ","date":"2021-10-17","objectID":"/javadairy/nginx/:7:0","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.2.1 什么是负载均衡* 负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。 ","date":"2021-10-17","objectID":"/javadairy/nginx/:7:1","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.2.2 配置负载均衡-准备工作* （1）将刚才的存放工程的tomcat复制三份，修改端口分别为8080 ，8081，8082 。 （2）分别启动这三个tomcat服务。 （3）为了能够区分是访问哪个服务器的网站，可以在首页标题加上标记以便区分。 ","date":"2021-10-17","objectID":"/javadairy/nginx/:7:2","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"*4.2.3 配置负载均衡* 修改 Nginx配置文件： upstream tomcat-travel { server 192.168.177.129:8080; server 192.168.177.129:8081; server 192.168.177.129:8082; } server { listen 80; # 监听的端口 server_name www.hmtravel.com; # 域名或ip location / { # 访问路径配置 # root index; # 根目录 proxy_pass http://tomcat-travel; index index.html index.htm; # 默认首页 } error_page 500 502 503 504 /50x.html; # 错误页面 location = /50x.html { root html; } } 地址栏输入http:// www.hmtravel.com / 刷新观察每个网页的标题，看是否不同。 经过测试，三台服务器出现的概率各为33.3333333%，交替显示。 如果其中一台服务器性能比较好，想让其承担更多的压力，可以设置权重。 比如想让NO.1出现次数是其它服务器的2倍，则修改配置如下： upstream tomcat-travel { server 192.168.177.129:8080; server 192.168.177.129:8081 weight=2; server 192.168.177.129:8082; } 经过测试，每刷新四次，有两次是8081 ","date":"2021-10-17","objectID":"/javadairy/nginx/:7:3","tags":null,"title":"Nginx","uri":"/javadairy/nginx/"},{"categories":null,"content":"Linux学习 输入ifconfig 查询ip地址,以后用于远程连接,我的192.168.122.128,使用CRT去远程连接服务器. ","date":"2021-10-17","objectID":"/note/linux/:0:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"常用命令 文件里有文档可以查 cd pwd li li -a li -l == ll 按tab可以补文件名称 cd .. 退回上一级 cd - 放回上一次的目录 mkdir 加上-p可以创建多级目录 rmdir 只能删除空文件 cat 查看全部 more 空格满屏 回车一行 less 上下键翻动 q退出 tail -f 动态查看实时监控 cp (copy) cp 文件名 粘贴的路径,可改名 mv (move) ./ 当前目录 ../上一级目录 rm 删除文件 回复y或者n rm -r 删除文件夹 rm -rf 删除且不询问 rm -f * 删除所有文件 rm -f / root目录下所有文件* tar 打包或者解压 【find】命令 find指令用于查找符合条件的文件 示例： find / -name “ins*” 查找文件名称是以ins开头的文件 find / -name “ins*” –ls find / –user itcast –ls 查找用户itcast的文件 find / –user itcast –type d –ls 查找用户itcast的目录 find /-perm -777 –type d-ls 查找权限是777的文件 【grep】命令 查找文件里符合条件的字符串。 用法: grep [选项]… PATTERN [FILE]…示例： grep lang anaconda-ks.cfg 在文件中查找lang grep lang anaconda-ks.cfg –color 高亮显示 【touch】 创建一个空文件 * touch a.txt 【clear/ crtl + L】 清屏 ","date":"2021-10-17","objectID":"/note/linux/:1:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"Vi和Vim编辑器 ","date":"2021-10-17","objectID":"/note/linux/:2:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"1． *Vim**编辑器：* 在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。三种模式：命令行、插入、底行模式。 切换到命令行模式：按Esc键； 切换到插入模式：按 i 、o、a键； i 在当前位置前插入 I 在当前行首插入 a 在当前位置后插入 A 在当前行尾插入 o 在当前行之后插入一行 O 在当前行之前插入一行 切换到底行模式：按 :（冒号）；更多详细用法，查询文档《Vim命令合集.docx》和《vi使用方法详细介绍.docx》 打开文件：vim file 退出：esc à :q 修改文件：输入i进入插入模式 保存并退出：escà:wq 不保存退出：escà:q! 三种进入插入模式： i:在当前的光标所在处插入 o:在当前光标所在的行的下一行插入 a:在光标所在的下一个字符插入 快捷键： dd – 快速删除一行 yy - 复制当前行 nyy - 从当前行向后复制几行 p - 粘贴 R – 替换 ","date":"2021-10-17","objectID":"/note/linux/:3:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"2． *重定向输出**\u003e**和**»* \u003e 重定向输出，覆盖原有内容；» 重定向输出，又追加功能；示例： cat /etc/passwd \u003e a.txt 将输出定向到a.txt中 cat /etc/passwd » a.txt 输出并且追加 ifconfig \u003e ifconfig.txt ","date":"2021-10-17","objectID":"/note/linux/:4:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"3． *系统管理命令* ps 正在运行的某个进程的状态 ps –ef 查看所有进程 ps –ef | grep ssh 查找某一进程 kill 2868 杀掉2868编号的进程 kill -9 2868 强制杀死进程 ","date":"2021-10-17","objectID":"/note/linux/:5:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"4． *管道* | 管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例 ls –help | more 分页查询帮助信息 ps –ef | grep java 查询名称中包含java的进程 ifconfig | more cat index.html | more ps –ef | grep aio 一、 *Linux**的权限命令* ","date":"2021-10-17","objectID":"/note/linux/:6:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"1． *文件权限* 属主（user） 属组（group） *其他用户* r w x r w x r w x 4 2 1 4 2 1 4 2 1 r:对文件是指可读取内容 对目录是可以ls w:对文件是指可修改文件内容，对目录 是指可以在其中创建或删除子节点(目录或文件) x:对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录 ","date":"2021-10-17","objectID":"/note/linux/:7:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"2． Linux三种文件类型： 普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 设备文件： Linux系统把每一个设备都看成是一个文件 ","date":"2021-10-17","objectID":"/note/linux/:8:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"3． 文件类型标识 普通文件（-）目录（d）符号链接（l） * 进入etc可以查看，相当于快捷方式字符设备文件（c）块设备文件（s）套接字（s）命名管道（p） ","date":"2021-10-17","objectID":"/note/linux/:9:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"4．文件权限管理： ​ chmod 变更文件或目录的权限。 chmod 755 a.txt chmod u=rwx,g=rx,o=rx a.txt 二、Linux上常用网络操作 ","date":"2021-10-17","objectID":"/note/linux/:10:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"1．主机名配置 hostname 查看主机名 hostname xxx 修改主机名 重启后无效 如果想要永久生效，可以修改/etc/sysconfig/network文件 ","date":"2021-10-17","objectID":"/note/linux/:11:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"2．IP地址配置 ifconfig 查看(修改)ip地址(重启后无效) ifconfig eth0 192.168.12.22 修改ip地址 如果想要永久生效 修改 /etc/sysconfig/network-scripts/ifcfg-eth0文件 DEVICE=eth0 #网卡名称 BOOTPROTO=static #获取ip的方式(static/dhcp/bootp/none) HWADDR=00:0C:29:B5:B2:69 #MAC地址 IPADDR=12.168.177.129 #IP地址 NETMASK=255.255.255.0 #子网掩码 NETWORK=192.168.177.0 #网络地址 BROADCAST=192.168.0.255 #广播地址 NBOOT=yes # 系统启动时是否设置此网络接口，设置为yes时，系统启动时激活此设备。 ","date":"2021-10-17","objectID":"/note/linux/:12:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"3． 域名映射 /etc/hosts文件用于在通过主机名进行访问时做ip地址解析之用,相当于windows系统的C:\\Windows\\System32\\drivers\\etc\\hosts文件的功能 ","date":"2021-10-17","objectID":"/note/linux/:13:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"4．网络服务管理 service network status 查看指定服务的状态 service network stop 停止指定服务 service network start 启动指定服务 service network restart 重启指定服务 service –status–all 查看系统中所有后台服务 netstat –nltp 查看系统中网络进程的端口监听情况 防火墙设置 防火墙根据配置文件/etc/sysconfig/iptables来控制本机的”出”、”入”网络访问行为。 service iptables status 查看防火墙状态 service iptables stop 关闭防火墙 service iptables start 启动防火墙 chkconfig iptables off 禁止防火墙自启 三、Linux上软件安装 l Linux上的软件安装有以下几种常见方式介绍 \\1. 二进制发布包 软件已经针对具体平台编译打包发布，只要解压，修改配置即可 \\2. RPM包 软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装 \\3. Yum在线安装 软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题 \\4. 源码编译安装 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。 l 上传与下载工具介绍 \\1. FileZilla \\2. lrzsz 我们可以使用yum安装方式安装 yum install lrzsz 注意：必须有网络 可以在crt中设置上传与下载目录 上传： 下载 ","date":"2021-10-17","objectID":"/note/linux/:14:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"1． 在Linux上安装JDK: 【步骤一】：上传JDK到Linux的服务器. * 上传JDK * 卸载open-JDK java –version rpm -qa | grep java rpm -e –nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686 rpm -e –nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686 【步骤二】：在Linux服务器上安装JDK. * 通常将软件安装到/usr/local * 直接解压就可以 tar –xvf jdk.tar.gz -C 目标路径 【步骤三】：配置JDK的环境变量. 配置环境变量： ① vi /etc/profile ② 在末尾行添加 ​ #set java environment ​ JAVA_HOME=/usr/local/jdk/jdk1.7.0_71 ​ CLASSPATH=.:$JAVA_HOME/lib.tools.jar ​ PATH=$JAVA_HOME/bin:$PATH ​ export JAVA_HOME CLASSPATH PATH 保存退出 ③source /etc/profile 使更改的配置立即生效 ","date":"2021-10-17","objectID":"/note/linux/:15:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"2． 在Linux上安装Mysql: 【步骤一】：将mysql的安装文件上传到Linux的服务器. 将mysql的tar解压 将系统自带的mysql卸载 【步骤二】：安装MYSQL服务端 下面的提示是告诉我们root用户的密码第一次是随机生成的，它保存在/root/.mysql_secret中，第一次登录需要修改root密码 server端安装不上的原因:本来自带的mysql-lib未删除. # yum list | grep mysql 查询 # yum remove mysql-libs 然后就能安装上了 安装autoconf库 yum -y install autoconf 数据初始化 /usr/bin/mysql_install_db --user=mysql 在启动mysql /usr/bin/mysqladmin -u root password 'new-password'设置新密码 【步骤三】：安装MYSQL客户端 查看生成的root密码 报错:原因是没有启动mysql服务 需要开启mysql服务 执行下面操作报错，原因是第一次操作mysql必须修改root用户的密码 设置root用户的密码 l Mysql****服务加入到系统服务并自动启动操作： chkconfig –add mysql 自动启动： chkconfig mysql on 查询列表： chkconfig l 关于mysql远程访问设置 在linux中很多软件的端口都被”防火墙”限止，我们需要将防火墙关闭 防火墙打开3306端口 /sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT /etc/rc.d/init.d/iptables save /etc/init.d/iptables status 学习阶段我们也可以直接将防火墙关闭 service iptables stop; ","date":"2021-10-17","objectID":"/note/linux/:16:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"3．在Linux上安装tomcat: 1.Tomcat上传到linux上 2.将上传的tomcat解压 3.在tomcat/bin目录下执行 startup.sh（注意防火墙） 4.查看目标 tomcat/logs/catalina.out ","date":"2021-10-17","objectID":"/note/linux/:17:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"1． *在**Linux上安装redis* 【步骤一】安装gcc-c++ redis是C语言开发，安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境。 输入命令: yum install gcc-c++ ​ 输入y确认下载 输入y确认安装 安装 gcc 成功！ 【步骤二】安装redis \\1. 下载redis wget http://download.redis.io/releases/redis-3.0.4.tar.gz \\2. 解压 tar -xzvf redis-3.0.4.tar.gz \\3. 编译安装、 切换至程序目录，并执行make命令编译： cd redis-3.0.4 make 执行安装命令 make PREFIX=/usr/local/redis install make install安装完成后，会在/usr/local/bin目录下生成下面几个可执行文件，它们的作用分别是： redis-server：Redis服务器端启动程序 redis-cli：Redis客户端操作工具。也可以用telnet根据其纯文本协议来操作 redis-benchmark：Redis性能测试工具 redis-check-aof：数据修复工具 redis-check-dump：检查导出工具 【步骤三】配置redis \\1. 复制配置文件到/usr/local/redis/bin目录： cd redis-3.0.4 cp redis.conf /usr/local/redis/bin 【步骤四】启动redis \\1. 进入redis/bin目录 cd redis/bin 启动redis服务端 ./redis-server redis.conf \\2. 克隆新窗口，启动redis客户端 ./redis-cli ","date":"2021-10-17","objectID":"/note/linux/:18:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"2． *部署**项目到Linux* \\1. 修改pom配置 在pom.xml中添加 ​ 修改jdk版本1.7 ​ \\2. 修改项目 ​ 2.1 druid.properties \\3. 将war包上 ​ 2.2 header.html 1.3 route_de2.3 route_detail.html \\4. 将war包上传到 \\3. 使用package命令打包 \\4. 将travel.war上传到tomcat中的webapps目录 \\5. 重启tomcat \\6. 导出本地mysql数据，并导入linux中的mysql Failed to execute goal org.apache.maven.plugins:maven-war-plugin:2.2:war (default-war) on project travel: Execution default-war of goal org.apache.maven.plugins:maven-war-plugin:2.2:war failed: Unable to load the mojo 'war' in the plugin 'org.apache.maven.plugins:maven-war-plugin:2.2' due to an API incompatibility: org.codehaus.plexus.component.repository.exception.ComponentLookupException: Cannot access defaults field of Properties 报错,在pom.xml中添加下列代码之后就能打包了 \u003cbuild\u003e \u003c!-- To define the plugin version in your parent POM --\u003e \u003cpluginManagement\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-war-plugin\u003c/artifactId\u003e \u003cversion\u003e3.3.1\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/pluginManagement\u003e \u003c!-- To use the plugin goals in your POM or parent POM --\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-war-plugin\u003c/artifactId\u003e \u003cversion\u003e3.3.1\u003c/version\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e ","date":"2021-10-17","objectID":"/note/linux/:19:0","tags":null,"title":"Linux","uri":"/note/linux/"},{"categories":null,"content":"黑马旅游网案例 ","date":"2021-10-13","objectID":"/javadairy/example/:0:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"注册 \u003cscript\u003e /* * 表单校验： * 1.用户名：单词字符，长度8到20位 * 2.密码：单词字符，长度8到20位 * 3.email：邮件格式 * 4.姓名：非空 * 5.手机号：手机号格式 * 6.出生日期：非空 * 7.验证码：非空 * */ function checkUsername(){ var username = $(\"#username\").val(); var reg_username = /^\\w{8,20}$/; var flag = reg_username.test(username); if(flag){ $(\"#username\").css(\"border\",\"\"); }else{ $(\"#username\").css(\"border\",\"1px solid red\"); } return flag; } $(function (){ //表单提交时调用所有校验方法 $(\"#registerForm\").submit(function (){ return checkUsername() \u0026\u0026 checkPassword() \u0026\u0026 checkEmail() \u0026\u0026 checkName() \u0026\u0026 checkTelephone() \u0026\u0026 checkBirthday() \u0026\u0026 checkCheck(); }); //组件失去焦点时，调用对应的校验方法 $(\"#username\").blur(checkUsername); $(\"#password\").blur(checkPassword);//注意这里的checkPassword不要加括号 $(\"#email\").blur(checkEmail); $(\"#name\").blur(checkName); $(\"#telephone\").blur(checkTelephone); $(\"#birthday\").blur(checkBirthday); $(\"#check\").blur(checkCheck); }); \u003c/script\u003e 异步提交表单：在此使用异步提交表单是为了获取服务器响应的数据。因为我们前台使用的是html作为视图层，不能够直接从servlet相关的域对象获取值，只能通过ajax获取响应数据 用了一个filter解决全站的编码问题 ","date":"2021-10-13","objectID":"/javadairy/example/:1:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"邮件激活 为什么要进行邮件激活？为了保证用户填写的邮箱的正确的。将来可以推广一些宣传信息，到用户邮箱中。 发送邮件 qq邮箱发送需要授权码登录才能成功发送 private static final String USER = \"1972666358@qq.com\"; // 发件人称号，同邮箱地址 private static final String PASSWORD = \"xoleghbelfloefcd\"; // 如果是qq邮箱可以使户端授权码，或者登录密码 用户点击激活 ​ ","date":"2021-10-13","objectID":"/javadairy/example/:1:1","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"登录 ","date":"2021-10-13","objectID":"/javadairy/example/:2:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"退出 ","date":"2021-10-13","objectID":"/javadairy/example/:3:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"BaseServlet抽取 要坚守Servlet的数量，现在是一个功能一个servlet，将其优化为一个模块一个servlet，相当于在数据库中一张表对应一个servlet，在servlet中提供不同的方法，完成用户的请求。 完成方法分发 public class BaseServlet extends HttpServlet { @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //完成方法分发 //1.获取请求路径 String uri = req.getRequestURI(); System.out.println(\"请求uri:\"+uri); //2.获取方法名称 String methodName = uri.substring(uri.lastIndexOf('/') + 1); System.out.println(\"方法名称：\"+methodName); //3.获取方法对象method //this 代表调用的对象 try { Method method = this.getClass().getMethod(methodName,HttpServletRequest.class, HttpServletResponse.class); method.invoke(this,req,resp); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } //4.执行方法 } } ","date":"2021-10-13","objectID":"/javadairy/example/:4:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"分类条目 ","date":"2021-10-13","objectID":"/javadairy/example/:5:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"分类数据缓存优化 使用redis缓存 ","date":"2021-10-13","objectID":"/javadairy/example/:5:1","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"旅游线路分类 点击了不同的分类之后,将来看到的旅游路线不一样。通过分析数据库表结构，发现旅游线路表和分类表是多对一的关系。 redis中查询score(cid) 页面得到cid 通过location.search 获取cid: split切割获得cid 创建PageBean, RouteServlet RouteService RouteDao ","date":"2021-10-13","objectID":"/javadairy/example/:6:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"旅游线路名称查询 给搜索按钮绑定单击事件,获取输入框内容传递参数. ","date":"2021-10-13","objectID":"/javadairy/example/:7:0","tags":null,"title":"travel","uri":"/javadairy/example/"},{"categories":null,"content":"在cmd上运行mvn compile时出现编译错误 No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK? 输入mvn -v查看 查看环境变量 将JAVA_HOME路径修改为jdk的 重启cmd输入java -version检查是否配置成功 mvn -v 再次编译,成功 ","date":"2021-10-10","objectID":"/bugs/cmd%E4%B8%ADmvn_compile%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"Cmd中mvn_compile出现的问题","uri":"/bugs/cmd%E4%B8%ADmvn_compile%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"Apache下的一个项目管理工具 官网地址 maven.apache.org ","date":"2021-10-10","objectID":"/javadairy/maven/:0:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"配置环境目录 1.获得maven文件夹的目录F:\\software\\apache-maven-3.8.3 2.在环境变量中新建一个新的 系统变量 , MAVEN_HOME ,将文件目录给放上去 3.在Path中新建一个 %MAVEN_HOME%\\bin 完成,打开cmd mvn -v检查是否安装成功,注意如果一开始是有错误的,更正之后记得重新打开cmd ","date":"2021-10-10","objectID":"/javadairy/maven/:1:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"Maven仓库 Maven项目的仓库刚开始是没jar包的,当Maven项目需要jar包时先去查找本地仓库,如果没有再从中央仓库(由Maven团队设立的一个唯一的仓库)下载到本地仓库. 远程仓库好处:可先去获取中央仓库中的jar包,提高本地仓库获取的速度,也可以放置一些公司自己写的jar包. cmd中在Maven项目的目录下mvn compile创建默认位置本地仓库 ","date":"2021-10-10","objectID":"/javadairy/maven/:2:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"修改本地仓库位置 打开maven目录下的conf目录下的setting.xml \u003clocalRepository\u003e/path/to/local/repo\u003c/localRepository\u003e 修改为想要的路径,例如 \u003clocalRepository\u003eF:\\software\\apache-maven-3.8.3\\mvn_repository\u003c/localRepository\u003e 再加入配置文件中 访问中央仓库太慢的话,课访问国内的私服,例如阿里云的私服 配置到setting.xml里面mirror部分 \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e ","date":"2021-10-10","objectID":"/javadairy/maven/:2:1","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"目录结构 ![](https://i.loli.net/2021/10/10/xeV6EHDjUpTdqG9.png ","date":"2021-10-10","objectID":"/javadairy/maven/:3:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"常用命令 mvn compile ​ 编译出字节码文件,在target目录下 mvn clean ​ 删除target目录 mvn package ​ 对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包,同时先编译了。 mvn install ​ 本地的当前项目安装到本地仓库中 ","date":"2021-10-10","objectID":"/javadairy/maven/:4:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"生命周期 maven 对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是： Clean Lifecycle 在进行真正的构建之前进行一些清理工作。 Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle 生成项目报告，站点，发布站点。 同一套生命周期中，执行后边的操作，会自动执行前边所有操作 ","date":"2021-10-10","objectID":"/javadairy/maven/:5:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"ideal中配置maven ","date":"2021-10-10","objectID":"/javadairy/maven/:6:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"坐标 \u003c!--项目名称，定义为组织名+项目名，类似包名--\u003e \u003cgroupId\u003ecn.itcast.maven\u003c/groupId\u003e \u003c!-- 模块名称 --\u003e\u003cartifactId\u003emaven-first\u003c/artifactId\u003e \u003c!-- 当前项目版本号，snapshot 为快照版本即非正式版本，release 为正式发布版本 --\u003e \u003cversion\u003e0.0.1-SNAPSHOT\u003c/version\u003e \u003cpackaging \u003e ：打包类型 jar：执行 package 会打成 jar 包 war：执行 package 会打成 war 包 pom ：用于 maven 工程的继承，通常父工程设置为 pom 坐标来源 添加依赖需要指定依赖 jar 包的坐标，但是很多情况我们是不知道 jar 包的的坐标，可以通过如下方 式查询：从互联网搜索 http://search.maven.org/ http://mvnrepository.com/ ","date":"2021-10-10","objectID":"/javadairy/maven/:7:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"依赖范围 A 依赖 B，需要在 A 的 pom.xml 文件中添加 B 的坐标，添加坐标时需要指定依赖范围，依赖范围包 括： ​ compile：编译范围，指 A 在编译时依赖 B，此范围为默认依赖范围。编译范围的依赖会用在 编译、测试、运行，由于运行时需要所以编译范围的依赖会被打包。 ​ provided：provided 依赖只有在当 JDK 或者一个容器已提供该依赖之后才使用， provided 依 赖在编译和测试时需要，在运行时不需要，比如：servlet api 被 tomcat 容器提供。 ​ runtime：runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如：jdbc 的驱动包。由于运行时需要所以 runtime 范围的依赖会被打包。 ​ test：test 范围依赖 在编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用， 比如：junit。由于运行时不需要所以 test范围依赖不会被打包。 ​ system：system 范围依赖与 provided 类似，但是你必须显式的提供一个对于本地系统中 JAR 文件的路径，需要指定 systemPath 磁盘路径，system依赖不推荐使用。 测试总结：  默认引入 的 jar 包 ——- compile 【默认范围 可以不写】（编译、测试、运行 都有效 ）  servlet-api 、jsp-api ——- provided （编译、测试 有效,运行时无效 防止和 tomcat 下 jar 冲突,tomcat中已经有了）  jdbc 驱动 jar 包 —- runtime （测试、运行 有效 ）  junit —– test （测试有效） 依赖范围由强到弱的顺序是：compile\u003eprovided\u003eruntime\u003etest ","date":"2021-10-10","objectID":"/javadairy/maven/:8:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"设置jdk编译版本 \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-compiler-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003csource\u003e1.8\u003c/source\u003e \u003ctarget\u003e1.8\u003c/target\u003e \u003cencoding\u003eUTF-8\u003c/encoding\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e ","date":"2021-10-10","objectID":"/javadairy/maven/:9:0","tags":null,"title":"Maven","uri":"/javadairy/maven/"},{"categories":null,"content":"Itellidea2021版本中web项目的配置 右键项目名称，选择Add Frameworks Support，勾选Web Application，OK。 添加Tomcat 点右上角 或者菜单栏中Run中的Edit Configurations 这个自己配置 回到打开project structure –\u003e Modules 选择添加library 添加Tomcat包之后选择web，勾选下方的SourceRoots，这样才能直接new servlet 注意重启idea后这个勾会没打上，所以要自己打上 ","date":"2021-10-09","objectID":"/note/ideal2021javaweb%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/:0:0","tags":null,"title":"Ideal2021JavaWeb项目配置","uri":"/note/ideal2021javaweb%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/"},{"categories":null,"content":"Windows下redi-server.exe秒退 遇到个问题： 在第一次正常启动之后，配置完conf里的save，再次开启server秒退。 错误信息：QForkMasterInit: system error caught. error code=0x000005af, message=VirtualAllocEx failed.: unknown error **原因：**未设置redis最大内存 **解决：**在conf中最下面加入 maxmemory 268435456 maxheap 314572800 再次启动正常 在目录下打开cmd 输入 redis-server.exe redis.windows.conf ","date":"2021-10-09","objectID":"/bugs/windows%E4%B8%8Bredi-server.exe%E7%A7%92%E9%80%80/:1:0","tags":null,"title":"Windows下redis-Server秒退","uri":"/bugs/windows%E4%B8%8Bredi-server.exe%E7%A7%92%E9%80%80/"},{"categories":null,"content":"redis\u0026Jedis ","date":"2021-10-09","objectID":"/javadairy/redisjedis/:0:0","tags":null,"title":"Redis\u0026Jedis","uri":"/javadairy/redisjedis/"},{"categories":null,"content":"redis 概念：一款高性能的NOSQL系列的非关系型数据库 关系型数据库：MySQL、Oracle… ​ 使用表单存储数据，数据之间有关联关系，数据存储在硬盘的文件上 非关系型数据库(NOSQL): redis, hbase… ​ 使用键值对去存储数据，数据之间没有关联关系，数据存储在内存中 两种数据库并非对立而是互补，关系型用来做数据库，NOSQL用于做缓存、秒杀任务队列、网站访问统计等 去https://redis.io官网下载的只有Linux系统的redis，先用着黑马的Windows绿色版本，等后边部署Linux的时候再使用 key，value； 其中key都是字符串，value有5种不同的数据结构 value： ​ 1.字符串类型string ​ 2.哈希类型hash：map格式 ​ 3.列表类型list： linkedlist格式 ​ 4.集合类型set ​ 5.有序集合类型sortedset ","date":"2021-10-09","objectID":"/javadairy/redisjedis/:1:0","tags":null,"title":"Redis\u0026Jedis","uri":"/javadairy/redisjedis/"},{"categories":null,"content":"**命令操作 ** (更多详细的操作在redis官网文档中有) 字符串类型 string 1. 存储： set key value 127.0.0.1:6379\u003e set username zhangsan OK 2. 获取： get key 127.0.0.1:6379\u003e get username \"zhangsan\" 3. 删除： del key 127.0.0.1:6379\u003e del age (integer) 1 哈希类型 hash 存储： hset key field value 127.0.0.1:6379\u003e hset myhash username lisi (integer) 1 127.0.0.1:6379\u003e hset myhash password 123 (integer) 1 获取： hget key field: 获取指定的field对应的值 127.0.0.1:6379\u003e hget myhash username “lisi” hgetall key：获取所有的field和value 127.0.0.1:6379\u003e hgetall myhash “username” “lisi” “password” “123” 删除： hdel key field 127.0.0.1:6379\u003e hdel myhash username (integer) 1 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边） 添加： lpush key value: 将元素加入列表左表 rpush key value：将元素加入列表右边 127.0.0.1:6379\u003e lpush myList a (integer) 1 127.0.0.1:6379\u003e lpush myList b (integer) 2 127.0.0.1:6379\u003e rpush myList c (integer) 3 获取： lrange key start end ：范围获取 127.0.0.1:6379\u003e lrange myList 0 -1 “b” “a” “c” 删除： lpop key： 删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set ： 不允许重复元素 1. 存储：sadd key value 127.0.0.1:6379\u003e sadd myset a (integer) 1 127.0.0.1:6379\u003e sadd myset a (integer) 0 2. 获取：smembers key:获取set集合中所有元素 127.0.0.1:6379\u003e smembers myset 1) “a” 3. 删除：srem key value:删除set集合中的某个元素 127.0.0.1:6379\u003e srem myset a (integer) 1 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 127.0.0.1:6379\u003e zadd mysort 60 zhangsan (integer) 1 127.0.0.1:6379\u003e zadd mysort 50 lisi (integer) 1 127.0.0.1:6379\u003e zadd mysort 80 wangwu (integer) 1 获取：zrange key start end [withscores] 127.0.0.1:6379\u003e zrange mysort 0 -1 “lisi” “zhangsan” “wangwu” 127.0.0.1:6379\u003e zrange mysort 0 -1 withscores “zhangsan” “60” “wangwu” “80” “lisi” “500” 删除：zrem key value 127.0.0.1:6379\u003e zrem mysort lisi (integer) 1 通用命令 keys * : 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value ","date":"2021-10-09","objectID":"/javadairy/redisjedis/:1:1","tags":null,"title":"Redis\u0026Jedis","uri":"/javadairy/redisjedis/"},{"categories":null,"content":"持久化 redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 redis持久化机制： RDB：默认方式，不需要进行配置，默认就使用这种机制 在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 after 900 sec (15 min) if at least 1 key changed save 900 1 after 300 sec (5 min) if at least 10 keys changed save 300 10 after 60 sec if at least 10000 keys changed save 60 10000 重新启动redis服务器，并指定配置文件名称 F:\\NewStudy\\JavaWeb\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9\\redis.windows.conf\u003eredis-server.exe redis.windows.conf AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windwos.conf文件 appendonly no（关闭aof） –\u003e appendonly yes （开启aof） appendfsync always ： 每一次操作都进行持久化 appendfsync everysec ： 每隔一秒进行一次持久化 appendfsync no ： 不进行持久化 遇到个问题： 在第一次正常启动之后，配置完conf里的save，再次开启server秒退。 错误信息：QForkMasterInit: system error caught. error code=0x000005af, message=VirtualAllocEx failed.: unknown error **原因：**未设置redis最大内存 **解决：**在conf中最下面加入 maxmemory 268435456 maxheap 314572800 再次启动正常 ","date":"2021-10-09","objectID":"/javadairy/redisjedis/:1:2","tags":null,"title":"Redis\u0026Jedis","uri":"/javadairy/redisjedis/"},{"categories":null,"content":"Jedis Java客户端 Jedis * Jedis: 一款java操作redis数据库的工具. * 使用步骤： 1. 下载jedis的jar包 2. 使用 //1. 获取连接 Jedis jedis = new Jedis(\"localhost\",6379); //2. 操作 jedis.set(\"username\",\"zhangsan\"); //3. 关闭连接 jedis.close(); * Jedis操作各种redis中的数据结构 1) 字符串类型 string set get //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 //存储 jedis.set(\"username\",\"zhangsan\"); //获取 String username = jedis.get(\"username\"); System.out.println(username); //可以使用setex()方法存储可以指定过期时间的 key value jedis.setex(\"activecode\",20,\"hehe\");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对 //3. 关闭连接 jedis.close(); 2) 哈希类型 hash ： map格式 hset hget hgetAll //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // 存储hash jedis.hset(\"user\",\"name\",\"lisi\"); jedis.hset(\"user\",\"age\",\"23\"); jedis.hset(\"user\",\"gender\",\"female\"); // 获取hash String name = jedis.hget(\"user\", \"name\"); System.out.println(name); ​ // 获取hash的所有map中的数据 Map\u003cString, String\u003e user = jedis.hgetAll(\"user\"); // keyset Set\u003cString\u003e keySet = user.keySet(); for (String key : keySet) { //获取value String value = user.get(key); System.out.println(key + \":\" + value); } //3. 关闭连接 jedis.close(); 3) 列表类型 list ： linkedlist格式。支持重复元素 lpush / rpush lpop / rpop lrange start end : 范围获取 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // list 存储 jedis.lpush(\"mylist\",\"a\",\"b\",\"c\");//从左边存 jedis.rpush(\"mylist\",\"a\",\"b\",\"c\");//从右边存 // list 范围获取 List\u003cString\u003e mylist = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist); // list 弹出 String element1 = jedis.lpop(\"mylist\");//c System.out.println(element1); String element2 = jedis.rpop(\"mylist\");//c System.out.println(element2); // list 范围获取 List\u003cString\u003e mylist2 = jedis.lrange(\"mylist\", 0, -1); System.out.println(mylist2); //3. 关闭连接 jedis.close(); 4) 集合类型 set ： 不允许重复元素 sadd smembers:获取所有元素 //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 ​ // set 存储 jedis.sadd(\"myset\",\"java\",\"php\",\"c++\"); // set 获取 Set\u003cString\u003e myset = jedis.smembers(\"myset\"); System.out.println(myset); //3. 关闭连接 jedis.close(); 5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 zadd zrange //1. 获取连接 Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口 //2. 操作 // sortedset 存储 jedis.zadd(\"mysortedset\",3,\"亚瑟\"); jedis.zadd(\"mysortedset\",30,\"后裔\"); jedis.zadd(\"mysortedset\",55,\"孙悟空\"); // sortedset 获取 Set\u003cString\u003e mysortedset = jedis.zrange(\"mysortedset\", 0, -1); System.out.println(mysortedset); ​ //3. 关闭连接 jedis.close(); ​ * jedis连接池： JedisPool * 使用： 1. 创建JedisPool连接池对象 2. 调用方法 getResource()方法获取Jedis连接 //0.创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50); config.setMaxIdle(10); //1.创建Jedis连接池对象 JedisPool jedisPool = new JedisPool(config,\"localhost\",6379); //2.获取连接 Jedis jedis = jedisPool.getResource(); //3. 使用 jedis.set(\"hehe\",\"heihei\"); ​ Jedis工具类 //4. 关闭 归还到连接池中 jedis.close(); * 连接池工具类 public class JedisPoolUtils { private static JedisPool jedisPool; static{ //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try { pro.load(is); } catch (IOException e) { e.printStackTrace(); } //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\"))); config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty(\"host\"),Integer.parseInt(pro.getProperty(\"port\"))); ​ ​ } ​ /** * 获取连接方法 */ public static Jedis getJedis(){ return jedisPool.getResource(); } } #最大活动对象数 redis.pool.maxTotal=1000 #最大能够保持idel状态的对象数 redis.pool.maxIdle=100 #最小能够保持idel状态的对象数 redis.pool.minIdle=50 #当池内没有返回对象时，最大等待时间 redis.pool.maxWaitMillis=10000 #当调用borrow Object方法时，是否进行有效性检查 redis.pool.testOnBorrow=true #当调用return Object方法时，是否进行有效性检查 redis.pool.testOnReturn=true #“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1. redis.pool.timeBetweenEvictionRunsMillis=30000 #向调用者输出“链接”对象时，是否检测它的空闲超时； redis.pool.testWhileIdle=true # 对","date":"2021-10-09","objectID":"/javadairy/redisjedis/:2:0","tags":null,"title":"Redis\u0026Jedis","uri":"/javadairy/redisjedis/"},{"categories":null,"content":"案例： 案例需求： 1. 提供index.html页面，页面中有一个省份 下拉列表 2. 当 页面加载完成后 发送ajax请求，加载所有省份 * 注意：使用redis缓存一些不经常发生变化的数据。 * 数据库的数据一旦发生改变，则需要更新缓存。 * 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入 * 在service对应的增删改方法中，将redis数据删除。 ","date":"2021-10-09","objectID":"/javadairy/redisjedis/:3:0","tags":null,"title":"Redis\u0026Jedis","uri":"/javadairy/redisjedis/"},{"categories":null,"content":"1.旅行终点站 简单 2021.10.08 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。 解题的思路就是遍历一遍paths，取cityB，第二重遍历取cityA，当第二重遍历的cityA等于第一重遍历的cityB时说明这条路线是有出路的，反之当第二重遍历结束后依然没有对应的cityA，说明此时第一重遍历的cityB即为终点。 但是实现方式过于单一，没有去向其他更快捷的方式，导致速度太慢，参考官方题解当中，利用哈希表HashSet去储存一组需要遍历的量，提高速度。 class Solution { public String destCity(List\u003cList\u003cString\u003e\u003e paths) { for(int i=0; i\u003cpaths.size(); i++){ for(int j=0; j\u003cpaths.size(); j++){ if(i!=j \u0026\u0026 paths.get(i).get(1).equals(paths.get(j).get(0))){ break; }else if(j==paths.size()-1){ return paths.get(i).get(1); } } } return \"\"; } } //官方题解 class Solution { public String destCity(List\u003cList\u003cString\u003e\u003e paths) { Set\u003cString\u003e citiesA = new HashSet\u003cString\u003e(); for (List\u003cString\u003e path : paths) { citiesA.add(path.get(0)); } for (List\u003cString\u003e path : paths) { if (!citiesA.contains(path.get(1))) { return path.get(1); } } return \"\"; } } /*** 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/destination-city/solution/lu-xing-zhong-dian-zhan-by-leetcode-solu-pscd/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ***/ 官方题解速度2ms，自己的12ms。自己时间复杂度O(n²) 官方答案 时间复杂度：O(nm)，其中n是数组paths 的长度，m是城市名称的最大长度。 查看 contains public boolean contains(Object o) 如果此集合包含指定的元素，则返回true 。 更正式地，返回true当且仅当该集合包含元素e ，使得(o==null ? e==null : o.equals(e)) 。 ","date":"2021-10-09","objectID":"/leetcodedairy/20211008/:1:0","tags":null,"title":"2021.10.08","uri":"/leetcodedairy/20211008/"},{"categories":null,"content":"大话设计模式读书笔记 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:0:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"1.简单工厂模式 用一个单独的类来做创照实例的过程，这就是工厂 public class OperationFactory{ public static Operation createOperate(string operate){ Operation oper = null; switch(operate){ case \"+\": oper = new OperationAdd(); break; case \"-\": oper = new OperationSub(); break; case \"*\": oper = new OperationMul(); break; case \"/\": oper = new OperationMul(); break; } return oper; } } Operation oper; oper = OperationFactory.createOperate(\"+\"); oper.NumberA = 1; oper.NumberB = 2; double result = oper.GetResult(); ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:1:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"*UML类图 UML类图图示样例 类图 类图分为三层 第一层显示类的名称，如果是抽象类，则就用斜体显示。 第二层是类的特性，通常就是字段和属性。 第三层是类的操作，通常是方法或行为。 “+\"表示public，\"-“表示private ， “#“表示protected。 接口图 顶端有《interface》 第一行是接口名称 第二行是接口方法 继承 空心三角形+实线来表示 接口 空心三角形+虚线表示 关联 放一个类知道另一个类时，实线箭头来表示 class Penguin : Bird{ private Climate climate; } 聚合 “聚合表示一种弱的 ‘拥有’ 关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分” 用空心的菱形+实线箭头来表示 合成 “合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样” 用实心的菱形+实线箭头表示 依赖关系 虚线箭头表示 2021.10.08 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:1:1","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"2.策略模式 策略模式（Strategy）：它定义了 算法家族 ，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。 承担Strategy角色的一个类上定义所有支持的算法的公共接口，它的子类去实现各种不同的策略（算法）。 然后创建一个Context类，里面创建维护一个Strategy对象，（初始化需要做的判断可以放在这里，简单工厂和策略模式的结合，减轻客户端的压力）在初始化Context类的时候需要传入Strategy参数，这里传入的应该是Strategy的子类也就是各种实际的策略。在ContextInterface()中用strategy去调用Strategy中的那个公共接口，最后得到响应策略（算法）的结果，返回给客户端。 书本案例—市场促销 class CashContext{ CashSuper cs = null; public CashContext (string type){ case \"正常收费\": CashNormal cs0 = new CashNormal(); cs = cs0; break; case \"满300返100\": CashNormal cr1 = new CashReturn(\"300\",\"100\"); cs = cr1; break; case \"打8折\": CashNormal cr2 = new CashNormal(\"0.8\"); cs = cr2; break; } public double GetResult(double money){ return cs.acceptCash(money); } } //客户端窗体程序(主要部分) doule total = 0.0d; private void btnOk_Click(Object sender,EvenArgs e){ CashContext csuper = new CashContext(cbxType.SelectedItem.ToString()); double totalPrices = 0d; totalPrices = csuper.getResult(Conver.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text)); total = total + totalPrices; lbxList.Items.Add(\"单价\" + txtPrice.Text + \"数量\" + txtNum.Text + \" \" + cbxType.SelectedItem + \" 合计：\" + totalPrices.ToString()); lblResult.Text = total.ToString(); } “策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能” “上例子的公共功能就是获得计算费用的结果，GetResult，这使得算法之间有了抽象的父类CashSuper” 策略模式另一个优点就是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 策略模式就是用来封装算法的，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:2:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"3.单一职责原则 “如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD]” “软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的东西去改变一个类，那么这个类就具有多于一个的职责[ASD]” ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:3:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"4.开放-封闭原则 开放-封闭原则，是说软件实体(类、模块、函数等等)应该是可拓展，但是不可修改 对于拓展是开放的(Open for extension)，对于更改是封闭的(Closed for modification) 在最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。例如写个简单的加法程序，开始直接在client类中完成，但是得想到后来需要增加一些其他运算的功能，于是增加一个抽象的运算类，利用一些如继承，多态等来隔离具体加法、减法与client耦合，如后续要增加乘法除法功能，就不需要再去更改client以及加法减法的类了，而是增加乘法和除法的子类就好。 面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:4:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"5.依赖倒转原则 抽象不应该依赖细节，细节应该依赖于抽象，说白了就是要对接口编程，不要对实现编程。 A.高层模块不应该依赖低层模块。两个都应该依赖抽象。 B.抽象不应该依赖细节。细节应该依赖抽象。 高层模块依赖于低层模块，如果需要用不同数据库或存储信息方式，那么连高层模块都不能使用了。 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:5:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"#里氏代换原则 一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上添加新的行为，也就是因为这个才使得使用父类类型的模块在无需修改的情况下就可以扩展。 例如企鹅不能继承鸟类，虽然在生物学上企鹅是鸟类，但是在这说，企鹅不能飞，而鸟类指可以飞的，企鹅不能替换掉鸟类，所以不能继承。 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:5:1","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"6.装饰模式 装饰模式，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。 //Person类 ConcreteComponent class Preson{ public Person(){} private string name; public Person(string name){ this.name = name; } public virtual void Show(){ Console.WriteLine(\"装扮的{0}\",name); } } //服饰类(Decorate) class Finery : Person{ protected Person component; //打扮 public void Decorate (Person component){ this.component = component; } public override void Show(){ if(component != null){ component.Show(); } } } //具体服饰类 (ConcreteDecorator) class TShirts : Finery{ public override void Show(){ Console.Write(\"大T恤\"); base.Show(); } } class BigTrouser : Finery{ public override void Show(){ Console.Write(\"垮裤\"); base.Show(); } } ..... static void Main(string[] args){ Person xc = new Person(\"小菜\"); Console.WriteLine(\"\\n第一种装扮:\"); Sneakers pqx = new Sneakers(); BigTrouser kk = new BigTrouser(); TShirts dtx = new TShirts(); pqx.Decorate(xc); kk.Decorate(pqx); dtx.Decorate(kk); dtx.show; Console.WriteLine(\"\\n第二种装扮\"); LeatherShoes px = new LeatherShoes(); Tie ld = new Tie(); Suit xz = new Suit(); px.Decorate(xc); ld.Decorate(px); xz.Decorate(ld); xz.Show(); Console.Read(); } 装饰模式是为已有功能动态地添加更多功能的一种方式,系统需要新的功能的时候,是向旧的类中添加新的代码,这些代码通常装饰了原有类的核心职责或主要行为,例如要添加领带ld,也保留了原来的小菜xc和皮鞋px. 有效地把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:6:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"7.代理模式 代理模式，为其他对象提供一种代理以控制对这个对象的访问 ![f1ddfd24be4c0687ac682c58e3e708a](https://i.loli.net/2021/10/14/BIaoJKk197A6Fec.jpg //案例 1，远程代理，也就是为了一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的试试。 2，虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象 3，安全代理，用来控制真实对象访问时的权限 4，智能指引，是指当调用真实的对象时，代理处理另外一些事。 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:7:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"8.工厂方法模式 ","date":"2021-10-08","objectID":"/note/bigtalkdesignpattennote/:8:0","tags":null,"title":"BigTalkDesignPattenNote","uri":"/note/bigtalkdesignpattennote/"},{"categories":null,"content":"如何添加右键可选在此处打开命令行窗口 1.win+r 输入 regedit 回车打开注册表 2.切换到HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\ 右键shell，新建项 “OpenCMDHere” 并在该项下，右击新建项 “command” 直接点击OpenCMDHere将OpenCMDHere中的默认改为 在此处打开命令窗口 右键 新建字符串名，名字为Icon将值改为cmd.exe 创建 OpenCMDHere 的图片 3.修改command最终的默认值 输入 cmd.exe /s /k pushd \\\"%V\\\" ","date":"2021-10-01","objectID":"/note/note1/:1:0","tags":null,"title":"如何添加右键可选在此处打开命令行窗口","uri":"/note/note1/"},{"categories":null,"content":" web尽快过完一遍,直接进入后端框架的学习,做一些SSM框架的东西 基础: 算法, 计网TCP/IP HTTP UDP 等协议, 操作系统, MySQL, 设计模式, Linux基础命令 java: 复习多线程Thread,Runnable, Callable, 池化技术,JVM MySQL的进阶 重点查看索引,事务这方面 《自顶向下计算机网络》《图解HTTP》《mysql技术内幕InnoDB储存引擎》 Redis也要学习 《Redis设计与实现(第二版)》 《大话设计模式》 《鸟哥的Linux私房菜》 《java核心技术卷一》《深入理解java虚拟机》(2,3,6,7章) 《实战java高并发程序设计》《java并发编程的艺术》 每天都需要学习的: ​ java后端知识, CET6, 算法 分阶段去学习的: ​ MySQL强化 java进阶 项目 设计模式 计算机网络 Linux 任务 途径 每个部分都要写博客记录技术要点 java 先跟着黑马web看完把项目案例做完, 然后转向后端框架的学习 算法 算法第四版配上PTA使用, 后期刷LeetCode和面试题 项目 在项目中去学习MySQL进阶和Linux常用指令集 JVM 看书 计网 看书 设计模式 看书 ","date":"2021-09-30","objectID":"/post/project/:0:0","tags":null,"title":"Project","uri":"/post/project/"},{"categories":null,"content":"blog搭建和我的信息 现在已经安装好了hugo 在cmd中输入 hugo version可以查询 ","date":"2021-09-30","objectID":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/:0:0","tags":null,"title":"Blog搭建和我的信息","uri":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/"},{"categories":null,"content":"创建启动 hugo new site [path] [flags] 创建 这里是新创建了一个hugo new site F:\\myblog blog 到 themes.gohugo.io里面去下载主题直接在cmd中clone cd [path] git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c 然后启动 hugo server -t m10c –buildDrafts Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 通过本地链接就可以访问了 ","date":"2021-09-30","objectID":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/:1:0","tags":null,"title":"Blog搭建和我的信息","uri":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/"},{"categories":null,"content":"写一篇文章 hugo new post/hello.md git 令牌 ","date":"2021-09-30","objectID":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/:2:0","tags":null,"title":"Blog搭建和我的信息","uri":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/"},{"categories":null,"content":"生成public文件夹 hugo --theme=m10c --baseUrl=\"https://zyooo.github.io/\" --buildDrafts 每一次添加东西先生成然后commit push ","date":"2021-09-30","objectID":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/:3:0","tags":null,"title":"Blog搭建和我的信息","uri":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/"},{"categories":null,"content":"git操作 到public目录下 git add . git commit -m” \" git push origin main ","date":"2021-09-30","objectID":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/:4:0","tags":null,"title":"Blog搭建和我的信息","uri":"/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/"},{"categories":null,"content":"2021.09.27 flatter vt.奉承;自命不凡,使显得更漂亮 thrift n.节约,节俭; 海石竹 contrast n.差异,悬殊;截然不同的实物; vt.对照,对比. vi.有明显差异 pharmacy n.药房,药店;药剂学;配药学 pilgrim n.朝圣者,香客;清教徒前辈移民 glacier n.冰川，冰河 cholesterol n.胆固醇 asylum n.(政治)避难,庇护 corporal n.下士.adj.肉体的,身体的 gauge n.测量仪器,宽度,口径; vt.判断,测量,估算 prosper vi.繁荣,兴旺,发达 surgery n.外科手术;手术室;应诊时间 contingent 依情况而定的,n.代表团 corporate adj.公司的 ; 团体的 collaboration n.合作,协作;合作的成果;通敌 wrap vt.包裹,缠绕 n.披肩,围巾 incentive n.激励,动力,奖励 intensive 加强的;集中地;透彻的;加强器 tactic n.策略,手段; 战术,兵法 delude vt.欺骗哄骗 diagnose vtvi 诊断(病症) deficit n.逆差,赤字 formulate vt.规划,策划,构想;确切表达 formula 公式;计划;方案;配方;处方;分子式; ","date":"2021-09-29","objectID":"/note/note/:1:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.08 cordial 热情好客的 meticulous 小心谨慎的 dole 失业救济金; vt.发放,分发 anguish n.(精神或身上的)极度痛苦 orchestra n.管弦乐队 petty 琐碎的,不重要的,小气的 confide vt.吐露(隐私) stroll 散步,溜达,闲逛 query n.疑问,询问 vt.质疑,询问,对…表示怀疑 fraud 诈骗,骗子,骗局 jurisdiction 司法权,管辖权;管辖区域 avert vt.防止,避免;转移目光 defiance n.违抗,拒绝服从 terrific 极好的,极大的 clamp 紧紧抓住,加紧;固定;夹具,夹子 exponent 倡导者,拥护者;大师;指教 velocity 速度,速率 classification 分类,分级,类别 restraint n.克制,抑制,限制;安全装置 momentous 重大的,关键的,重要的 preside vi.主持,负责 chase v.追逐,追捕;追求,求爱;努力获得;急奔 n追捕.追赶 perfume 香水;芳香,香味 vt抹香水;使香气弥漫 fragrant 芳香的;愉快的 fragrance 香味;芬芳 blur 模糊不清的事物;使视线模糊;使模糊 dignity 端庄;尊敬;自尊 diligent 勤勉的;用功的,费尽心血的 elegant 高雅的,优雅的;讲究的;简洁的 advent n.到来,出现;降临节 burglar 破门盗窃,窃贼 strangle vt.扼死,勒死;限制,扼杀 complexion 面色,面容;性质,特性 clergy 神职人员 exclaim vivt.(因激动,愤怒等)呼喊,惊叫 dub 将…戏称为;为..配音 jerk 使猛然一动;猛地一动;蠢人 botany 植物学 commentary n.现场报道;评论性文章;讨论 fraction n.少量,一点儿;分数 pact 条约,协定,协议 colonel 上校 glossary 术语汇编,词汇表 pendulum n.钟摆,摇摆不定的事态或局面 renaissance 文艺复兴,重新流行 intact 完整无缺的,未受损伤的 ","date":"2021-09-29","objectID":"/note/note/:2:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.09 grip n，v紧握，抓紧；使感兴趣 hostage 人质 voucher 抵金券；凭单，收据 butt n.屁股；烟蒂；大桶；枪托 v.用头顶撞 magistrate 地方执法官 incumbent 在职者；在职的；有责任履行的 coherent 连贯的；条理清楚地 escalate 使不断恶化；扩大，增加 retort 反驳，回嘴 n.回应，反驳；蒸馏瓶；曲颈瓶 propagate 宣传，传播；繁殖，繁衍 destiny 命运；神意，命运之神 medieval 中世纪的 contagious 接触性传染的；有感染力的 stagger 蹒跚；使震惊；使错开 imprison v. 监禁；禁锢 artillery 火炮，大炮；炮兵部队 hysterical 歇斯底里的；极其可笑的 connotation 含义，隐含意义 clearance 清除；间隙；审核批准；许可 loom 赫然出现；逐渐逼近；织布机 excursion 短途旅游；涉足 terrain 地形，地势，地带 porch 门廊，门庭 preach 宣传；鼓吹；说教，唠叨 embroidery 刺绣图案，刺绣技术 vertical 垂直的；纵向的；垂直线；垂直面 discern 觉察出，了解；分辨出 majesty 雄伟壮观，庄严；陛下 crave v 渴望，热望；恳求，请求 aggregate 总数；总数的；总计达到；使聚集 magnitude 巨大；重要性；星等；震级 unveil vt 公布，退出；为…揭幕 conscientious 认真的，勤勤恳恳的 gracious 和蔼慈祥的；尊贵的；舒适的； 天哪 deplete vt 大量消耗，耗减 debut 初次登台，初次亮相 adversary 对手，敌手 ","date":"2021-09-29","objectID":"/note/note/:3:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.10 carve vtvi 雕刻,把(熟肉)切成块;刻;成功获得 atrocity (尤战争中的)残暴行为 vacant 空的;空缺的;茫然的 saturate vt 浸透,渗透;使饱和,使充斥 foam 泡沫橡胶;泡沫;泡沫剂; v起泡沫 wrench 猛拉,猛扭;使痛苦;扭伤;扳手 militia 民兵组织,国民卫队 apparatus 器械.,仪器;机构,组织;器官 symphony 交响乐,交响曲 benevolent 仁慈的,慈爱的 deduct vt.扣除,减去 counterfeit 伪造的,仿冒的;仿品,赝品; 仿造,伪造 spectator 观众 poise 镇定,沉着;体态,姿态; vtvi.使平衡,保持 condense v 凝结;浓缩;压缩,精简 hectic 繁忙的,忙乱的 submarine 潜艇;潜艇三明治; 海底的 foul 肮脏恶臭的;很令人不快的;vt n犯规 bronze 青铜;青铜色;铜牌; 青铜色的 etiquette 礼节,礼仪,行为准则,规矩 crouch vi 蹲伏,蜷缩;蹲着的姿势 augment vt 增大,加强,增加 defendant 被告 wholesome 有益健康的;在道德上有益的 stout 肥壮的;结实的;坚决的 黑啤酒 detriment n.伤害,损害,造成伤害的原因 satire n.讽刺,讽刺作品 sarcasm n.讽刺,嘲讽,挖苦 fort 要塞,堡垒 discriminate vi 歧视,区别对待 vivt.区分,辨别 inflict vt.使吃苦头,使遭受打击 dispatch 派遣;派送; scorn nvt.轻视,蔑视 subtract vivt.减,减去 arrogant 傲慢的,自大的 rhetoric 浮夸之词;修辞艺术 sprinkle vt.洒,撒 n.少量,一点,小雨 ","date":"2021-09-29","objectID":"/note/note/:4:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.11 ratify vt 批准，正式签署 franchise 特许权；特权企业；选举权 vt.出售选特许权 electoral 选举的，与选举有关的 divine 天赐的，神的；绝妙的； vt 猜测，探测 vibrate 使振动，使颤动 bowel 肠；深处，内部 lenient 仁慈的，宽大的 bilateral 双边的，双方的；两边对称的 wield vt.行使，支配；握着 doctrine 信条，教义，主义；正式声明 peddle vt.叫卖，兜售；宣传，传播 lash 猛击，狠打；鞭打，抽打；捆绑，捆紧；睫毛；鞭打；抽打 cathedral 大教堂 tribe 部落；一伙人；族 propaganda n.宣传，鼓吹 bribe 贿赂，贿赂品；向…行贿 canoe 独木舟；划独木舟，乘独木舟 stipulate vt.规定，约定，明确要求 cosmopolitan 世界性的；见多识广的；四海为家的人 barometer 气压计；指标 ","date":"2021-09-29","objectID":"/note/note/:5:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.12 tact 圆滑，老练 resent vt. 怨恨，憎恶 succession 一连串；继承；继承权 ventilate vt.使…通风 hurricane 飓风 hover vi. 盘旋，悬停；徘徊，摇摆不定 doze vi.打瞌睡，打盹儿，小睡 n 小睡 unilateral 一方的，单方面的，单边的 slaughter vt.屠杀，杀戮；使惨败； n.（对动物的）屠宰；（对人的）屠杀 unanimous 一致通过的；意见一致的 lime n 酸橙；石灰；酸橙树； 撒石灰 limb 肢，臂，腿；大树枝 limp 疲软的；无力的； 一瘸一拐地走； 一瘸一拐 robust 强健的；结实的，坚定地 stout 肥壮的;结实的;坚决的 黑啤酒 petition 请愿书；申诉书； vivt 请愿；申请；祈祷 exposition 博览会；清楚而详尽的解释 futile 突来的；无益的；无意义的 vain 徒劳的；自负的；虚荣的 dilute 稀释，冲淡；削弱，降低； 稀释了的，冲淡了的 trek 徒步旅行；路程； vi 缓慢前行；远足；徒步旅行 levy 征收额，税款； vt 征收，征（税） obscene 淫秽的，下流的；大的惊人的 discreet 谨慎的；不显眼的 inertia 惯性；缺乏活力，惰性 hibernate vi 冬眠 despise vt 蔑视，鄙视 annex vt 兼并，吞并 n 附属建筑；附件，附录 ","date":"2021-09-29","objectID":"/note/note/:6:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.13 infringe vtvi 违反，违背；侵犯 inference 推断的结果，结论；推论，推理 strand n股，缕；部分；海滨，海岸 vt.使滞留，使无法脱身；使搁浅； cloak n.斗篷，披风；遮盖物； vt.遮盖，掩盖 antenna n.触角，触须；天线 ","date":"2021-09-29","objectID":"/note/note/:7:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.14 merchandise n.商品，货品；指定商品 scandal n.丑闻，丑行；流言蜚语 miniature 很小的，微型的； 微型画，小画像；微缩模型； stigma 耻辱，羞辱 treaty n. 条约，协定 metabolism n.新陈代谢 retrospect n.回顾，回想 courtesy n.谦恭有礼的举止，礼貌 cemetery n.墓地，公墓 envisage vt.设想，展望 curfew n.宵禁，宵禁令，宵禁时间 monarchy 君主制；君主国；王室 shaft 电梯井，竖井；杆，柄；一束； vt.亏待，欺骗 judiciary 司法部，司法系统 circumstance 情况,情形;经济情况 unequal 不公平的;不相等的;不胜任的 clash n.冲突;差别,分歧;争执 fall vi.落下;跌倒;下跌;沦陷;发生 discrepancy 差异,不符合 startlingly 惊人地 fund-raising n.筹款,募捐 probe vtvi.盘问,追问,探究 determination 决心;决定;测定,查明 lodging 寄宿处;租住的房间 syllabus 教学大纲 glamorous 富有魅力的;令人向往的 ","date":"2021-09-29","objectID":"/note/note/:8:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.15 revise vt.改变;修改,修订;vtvi.(考前)复习 resort 度假胜地;采用的方法;vi.采取 grant vt.准予;承认 n(政府等的)拨款 notorious 臭名昭著的,声名狼藉的 hinder vt.阻碍,妨碍;阻止 undermine vt.逐渐削弱,损害 ","date":"2021-09-29","objectID":"/note/note/:9:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.16 divert vt.使转向;使分心;改变用途 ","date":"2021-09-29","objectID":"/note/note/:10:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.17 drastic 严厉的,极端的;巨大的 recipe n.食谱;原因,秘诀 extract 摘录,引文;浓缩物,精华;vt.提取;拔出;摘录;设法获取 spacious 广阔的,宽敞的 impact 作用,影响;装机,撞击力;vivt.对…产生影响;冲击,撞击 ","date":"2021-09-29","objectID":"/note/note/:11:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.18 dictate vtvi.口述;命令,规定;支配 n.命令,规定 perception n理解,看法;感知;洞察力 assemble vivt.(使)集合,聚集 ; 组装,装配 confront vt.勇敢面对;使面对;对峙;对质 deduce vt.推断,推理,演绎 hazard n.危险,隐患,危害 vt.大胆提出或猜测;使..冒风险 evident 明显的,显然的 commitment n承诺;信奉,献身;义务 fertilizer n.肥料,化肥 conceive vt.想象,想出,构想 vivt.怀孕 intimate 亲密的;隐私的;幽静舒适的; vt 透露,暗示; 知己,密友 demonstrate vt.证明;示范;展露 vi.示威 antibiotic 抗生素;抗生素的 compromise 折中;妥协;违背;危及 defy vt违抗;难以(描述);经受住 scheme n.计划,方案;阴谋; vivt.密谋 ","date":"2021-09-29","objectID":"/note/note/:12:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.19 sophisticated 见多识广的;精密的;老练的 specification 规格,具体要求 ","date":"2021-09-29","objectID":"/note/note/:13:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.20 lineage 世系,家族,血统 blot vt.吸干 n污点,墨渍 bulky 庞大的,笨重的;大块头的 marketers 卖方,销售者 stain 玷污,留下污渍;给…染色;败坏 n.污点;染色剂 courteous 有礼貌的,客气的,谦恭的 hard-line 坚定的,坚决的,强硬的 disclaim vt.否认,拒绝承认 stare at 凝视着;盯着看;注视着 gaze at 盯着…看 ,凝视着… glare at 瞪;怒视 render vt.致使;给予;表达;翻译 exception 例外;规则的例外;例外的事物 generalize vi.概括,归纳 vt.普及 momentum n.势头,冲劲;冲力;动量 trivial 琐碎的,微不足道的 nourish vt.给…提供营养;滋长 reproach n.责备;责备的话语;丢脸 vt.责备,为…感到内疚 ","date":"2021-09-29","objectID":"/note/note/:14:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.21 exceptional 杰出的;罕见的,异常的 turmoil 混乱,动荡 syndicate 辛迪加,企业组织,商业财团 sanitation 公共卫生 indict vt.控告,起诉 linen 亚麻布;亚麻制品 patronize 经常光顾;资助;以高人一等的态度对待 sob 抽噎,啜泣;哭诉;啜泣声 remnant 残余部分 cynical 愤世嫉俗的;无所顾忌的 evade vt.逃脱;逃避,规避;回避,避开 nasty 不友善的;令人不快的;严重的 ","date":"2021-09-29","objectID":"/note/note/:15:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.22 partisan 过分支持的,盲目拥护的; 游击队员 meticulous 小心谨慎的 panorama 全景,全景图;全貌,概述 brink 边缘,边沿 conducive 有利的,有助的,有益的 symmetry 对称;相似,相等 trumpet 喇叭,小号;vt吹嘘,宣扬 calcium 钙 cuisine n.烹饪;菜肴 cockpit 驾驶室 metropolitan 大城市的,大都会的 spouse 配偶 contention 不和,争执;看法 slight 轻微的;纤细的; n.轻视 vt.轻视 prerequisite 先决条件; 作为先决条件的 concise 简洁的,简明的 multilateral 多国的,多边的,多方面的 tentative 暂定的;犹豫不定的 parish 教区,小行政区 ","date":"2021-09-29","objectID":"/note/note/:16:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.23 strangle vt.扼死,勒死;限制,扼杀 pact n.条约,协定,协议 intact 完整无缺的,未受损伤的 ","date":"2021-09-29","objectID":"/note/note/:17:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.24 escalate vi,vt.不断恶化;扩大,增加 contagious 接触性传染的;有感染力的 propagate vt.宣传,传播;vt.vi.繁殖,繁衍 retort vt.反驳,回嘴;n回应,反驳;曲颈瓶,蒸馏器 stagger vi.vt.蹒跚, vt.使震惊;使错开;交错布局 hysterical 歇斯底里的;极其可笑的 groan vi.vt.呻吟,哼哼n呻吟声,哼哼声 fabric 织物,布料;结构,构造 partial 部分的;偏袒的;钟爱的 hum 哼;嗡嗡声 crow 乌鸦; vi.打鸣 vivt.自鸣得意 connotation n.含义,隐含意义 excursion 短途旅游;涉足 terrain 地形,地势,地带 porch 门廊,门厅 linear 直线的;线性的 tread 踩,踏,行走 ; 脚步声;轮胎的胎面; 梯面 wedge 楔子,楔形物;vt.将…挤入;把…楔牢 preach vivt.讲道;宣传,鼓吹; 说教,唠叨 ","date":"2021-09-29","objectID":"/note/note/:18:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.25 etiquette n.礼仪,礼节,行为准则,规矩 hectic 繁忙的,忙乱的 inflict 使吃苦头,使遭受打击 satire n.讽刺,讽刺作品 sarcasm n.讽刺,嘲讽,挖苦 exempt 被免除的;vt.豁免,免除 negligible 微不足道的,不值一提的 ","date":"2021-09-29","objectID":"/note/note/:19:0","tags":null,"title":"Vocabulary","uri":"/note/note/"},{"categories":null,"content":"2021.10.26 stipulate vt.规定,约定,明确需求 cosmopolitan 世界性的;见多识广的;四海为家的人 graze vt.vi.吃青草,vt.擦伤;放牧;轻擦,蹭 hatred n.仇恨,憎恶,敌意 negligent 疏忽的,粗心大意的 resemblance n.相似,类似 wield vt.行使,支配;握着 ","date":"2021-09-29","objectID":"/note/note/:20:0","tags":null,"title":"Vocabulary","uri":"/note/note/"}]