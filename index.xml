<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>JoyBoy</title>
    <link>https://zyooo.github.io/</link>
    <description>Recent content on JoyBoy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 24 Feb 2022 21:54:42 +0800</lastBuildDate><atom:link href="https://zyooo.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022-02-24</title>
      <link>https://zyooo.github.io/leetcodedairy/20220224/</link>
      <pubDate>Thu, 24 Feb 2022 21:54:42 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220224/</guid>
      <description>开始是直接遍历的方法得到数字, 后来想着如果是严格按照一个形式的话, 那么 一个复数中只会出现一个 &amp;lsquo;+&amp;rsquo;
并且将虚部和实部分割, 可以利用这个去直接得到abcd, 不过不知道底层代码, 估计速度也是差不多的
代码: 100% 100%
func complexNumberMultiply(num1 string, num2 string) string { a,b := parse(num1) c,d := parse(num2) return fmt.Sprintf(&amp;#34;%v+%vi&amp;#34;,(a*c-b*d),(a*d+b*c)) } func parse (num string)(int,int){ a,b := 0,0 i,fa,fb := 0,1,1 flag := true n := len(num) if num[0] == &amp;#39;-&amp;#39; { fa = -1 i = 1 } for ;i &amp;lt; n; i++{ if num[i] &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; num[i] &amp;lt;= &amp;#39;9&amp;#39;{ if flag { a = a*10 + int(num[i] - &amp;#39;0&amp;#39;) } else { b = b*10 + int(num[i] - &amp;#39;0&amp;#39;) } } if num[i] == &amp;#39;+&amp;#39; { flag = false } else if num[i] == &amp;#39;-&amp;#39; { flag = false fb = -1 } } return a*fa,b*fb } 代码:100% 94%</description>
    </item>
    
    <item>
      <title>2022-02-08</title>
      <link>https://zyooo.github.io/leetcodedairy/20220208/</link>
      <pubDate>Sun, 20 Feb 2022 20:07:20 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220208/</guid>
      <description>1001.网格照明 hard 2022.02.08 数据规模太大了, 原本想着硬模拟的后来还是放弃了
打算用map去存储行列和两个对角的情况, 但是又不知道怎么去表示同一条对角
官方题解:
func gridIllumination(n int, lamps, queries [][]int) []int { type pair struct{ x, y int } points := map[pair]bool{} row := map[int]int{} col := map[int]int{} diagonal := map[int]int{} antiDiagonal := map[int]int{} for _, lamp := range lamps { r, c := lamp[0], lamp[1] p := pair{r, c} if points[p] { continue } points[p] = true row[r]++ col[c]++ //用这个来表示哪条对角, 妙啊  diagonal[r-c]++ antiDiagonal[r+c]++ } ans := make([]int, len(queries)) for i, query := range queries { r, c := query[0], query[1] if row[r] &amp;gt; 0 || col[c] &amp;gt; 0 || diagonal[r-c] &amp;gt; 0 || antiDiagonal[r+c] &amp;gt; 0 { ans[i] = 1 } for x := r - 1; x &amp;lt;= r+1; x++ { for y := c - 1; y &amp;lt;= c+1; y++ { if x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= n || !</description>
    </item>
    
    <item>
      <title>Day14</title>
      <link>https://zyooo.github.io/leetcodedairy/20220109/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:58 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220109/</guid>
      <description>田忌赛马,打不过就送人头 代码逻辑
n := len(nums1) sort.Ints(nums1) //田忌的马 sort.Ints(nums2) //齐王的马  for i := n-1; i &amp;gt;= 0; i-- { if nums1[i] &amp;gt; nums2[i] { //比得过跟他比  } else { //比不过,换的垫底的来送人头  } } int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.length; // 给 nums2 降序排序  PriorityQueue&amp;lt;int[]&amp;gt; maxpq = new PriorityQueue&amp;lt;&amp;gt;( (int[] pair1, int[] pair2) -&amp;gt; { return pair2[1] - pair1[1]; //比较方式  } ); for (int i = 0; i &amp;lt; n; i++) { maxpq.</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220108/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:54 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220108/</guid>
      <description>滑动窗口问题 int left = 0, right = 0 for right &amp;lt; len(s) { //增大窗口  window.add(s[right]) right++ for window needs shrink{ window.remove(s[left]) left++ } } O(N)
框架 //滑动窗口算法框架 func slidingWindow(s, t string) { need := make(map[string]int) window := make(map[string]int) for _,c := range t{ need[string(c)]++ } left,right,valid := 0,0,0 for right &amp;lt; len(s) { //c是将移入窗口的字符  c := s[right] //右移窗口  right++ //对窗口内数据的一系列更新  ... //debug输出的位置  fmt.Printf(&amp;#34;window: [%d,%d)\n&amp;#34;,left,right) //判断左侧窗口是否要收缩  for window needs shrink{ //d 是将移出窗口的字符  d := s[left] //左移窗口  left++ //进行窗口内数据的一系列更新  .</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220107/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220107/</guid>
      <description>二分搜索 //搜素左侧边界 func left_bound(nums []int, target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩右侧边界  right = mid }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 2 //搜索右侧边界 func right_bound(nums int[], target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩左侧边界  left = mid + 1 }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 4 技巧: 从题目中抽象出一个自变量x , 一个关于x的函数f(x), 以及一个目标值 target , 同时还要满足以下条件 : 1.</description>
    </item>
    
    <item>
      <title>2022-01-06</title>
      <link>https://zyooo.github.io/leetcodedairy/20220106/</link>
      <pubDate>Thu, 06 Jan 2022 11:18:06 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220106/</guid>
      <description>15.三数之和 穷举,确定了第一个数字之后, 剩下两个数字就是 target = target - nums[i] 的twoSum问题
func twoSumTarget2(nums []int, start, target int) [][]int { var ans [][]int //sort.Ints(nums)  lo, hi := start, len(nums)-1 for lo &amp;lt; hi { sum := nums[lo] + nums[hi] left, right := nums[lo], nums[hi] if sum &amp;lt; target { for lo &amp;lt; hi &amp;amp;&amp;amp; nums[lo] == left { //跳过重复项,保证答案唯一  lo++ } } else if sum &amp;gt; target { for lo &amp;lt; hi &amp;amp;&amp;amp; nums[hi] == right { hi-- } } else { ans = append(ans, []int{nums[lo], nums[hi]}) for lo &amp;lt; hi &amp;amp;&amp;amp; nums[lo] == left { lo++ } for lo &amp;lt; hi &amp;amp;&amp;amp; nums[hi] == right { hi-- } } } return ans } func threeSumTarget(nums []int, target int) [][]int { sort.</description>
    </item>
    
    <item>
      <title>2022-01-05</title>
      <link>https://zyooo.github.io/leetcodedairy/20220105/</link>
      <pubDate>Wed, 05 Jan 2022 07:49:09 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220105/</guid>
      <description>1576.替换所有的问号 func modifyString(s string) string { data := []byte(s) for i := 0; i &amp;lt; len(data); i++ { if data[i] == &amp;#39;?&amp;#39; { for b := byte(&amp;#39;a&amp;#39;); b &amp;lt;= &amp;#39;c&amp;#39;; b++ { if !(i &amp;gt; 0 &amp;amp;&amp;amp; data[i-1] == b || i &amp;lt; len(data)-1 &amp;amp;&amp;amp; data[i+1] == b) { data[i] = b break } } } } return string(data[:]) } 一个点在于, 实际上只需要遍历三个字母,就可以找到适合的答案, 还有就是里面那个 if 语句很好的解决了i=0 和
i = length-1的问题.
[]byte和string之间的转化方式 res := []byte( s ) string(res)</description>
    </item>
    
    <item>
      <title>2022-01-04</title>
      <link>https://zyooo.github.io/leetcodedairy/20220104/</link>
      <pubDate>Tue, 04 Jan 2022 07:46:10 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220104/</guid>
      <description>19.删除链表的倒数第N个节点 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := new(ListNode) dummy.Next = head x := findFromEnd(dummy,n+1) //找到倒数第n+1个然后将倒数第n个删除  x.Next = x.Next.Next return dummy.Next } func findFromEnd(head *ListNode,k int) *ListNode{ p1,p2 := head,head for i := 0; i &amp;lt; k; i++{ p1 = p1.Next } for p1 != nil{ p1 = p1.</description>
    </item>
    
    <item>
      <title>2022-01-03</title>
      <link>https://zyooo.github.io/leetcodedairy/20220103/</link>
      <pubDate>Mon, 03 Jan 2022 18:29:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220103/</guid>
      <description>1185.一周中的第几天 难度简单92
给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
输入为三个整数：day、month 和 year，分别表示日、月、年。
您返回的结果必须是这几个值中的一个 {&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;}。
用了一个公式： W = (D + 2 * M + 3 * (M + 1) \ 5 + Y + Y \ 4 - Y \ 100 + Y \ 400+1) Mod 7
但是一月和二月要用13,14表示。
class Solution { public String dayOfTheWeek(int day, int month, int year) { String[] days = {&amp;#34;Sunday&amp;#34;,&amp;#34;Monday&amp;#34;,&amp;#34;Tuesday&amp;#34;,&amp;#34;Wednesday&amp;#34;,&amp;#34;Thursday&amp;#34;,&amp;#34;Friday&amp;#34;,&amp;#34;Saturday&amp;#34;}; if(month == 1){ month = 13; year--; }else if(month == 2){ month = 14; year --; } //W = (D + 2 * M + 3 * (M + 1) \ 5 + Y + Y \ 4 - Y \ 100 + Y \ 400+1) Mod 7  return days[(day + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400 + 1) % 7]; } } 23.</description>
    </item>
    
    <item>
      <title>GoToSea</title>
      <link>https://zyooo.github.io/note/gotosea/</link>
      <pubDate>Thu, 30 Dec 2021 16:29:46 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/gotosea/</guid>
      <description>下海计划 Plan A 转Go，实现项目产出；
项目小demo：尚硅谷上面的一些，之后在自己去找一些，尚硅谷上面也有一些go的数据结构算法。
八股文：计算机网络、操作系统、数据库、语言（go）、其他（redis、设计模式、容器、linux）；
八股快速上手直接看面经，参考师兄的笔记和面经：
​	笔记：https://www.yuque.com/books/share/e3d14e92-6bad-436a-96e0-5a024809d9be?#
​	面经：https://www.nowcoder.com/discuss/665699?source_id=profile_create_nctrack&amp;amp;channel=-1
刷题：牛客和力扣。
算法学习找个go语言版本的算法书籍或者学习笔记跟着刷题。
计划冲刺时间：2022年1-3月，四月份要去生产实习，4月24号回来，尽量在四月份前拿到offer，商量实习时间，争取转正，要到秋招的时候如果还没转正，准备一手秋招，好的实习可以作为跳板。
go的学习：b站上面找视频和项目，了解了生态之后再深入常用的架构和框架，注意做笔记，持续学习。
广州大厂：微信、网易、唯品会、字节跳动、百度等
PlanB All in plan A.</description>
    </item>
    
    <item>
      <title>Go_Day1</title>
      <link>https://zyooo.github.io/golangdairy/go_day1/</link>
      <pubDate>Thu, 30 Dec 2021 16:13:04 +0800</pubDate>
      
      <guid>https://zyooo.github.io/golangdairy/go_day1/</guid>
      <description>Hello, golang! Hello world package main //有main函数的话这里一定要有main  import &amp;#34;fmt&amp;#34; //一个项目一个main函数，和c一样，与java不同 func main() { fmt.Println(&amp;#34;Hello,World!&amp;#34;) fmt.Println(&amp;#34;Hello golang&amp;#34;) } 标识符 老规矩，不能数字开头、不能关键字、不能含运算符。
关键字    break default func interface select     case defer go map struct   chan else goto package switch   const fallthrough if range type   continue for import return var    除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：
   append bool byte cap close complex complex64 complex128 uint16     copy false float32 float64 imag int int8 int16 uint32   int32 int64 iota len make new nil panic uint64   print println real recover string true uint uint8 uintptr    空格 变量的声明必须使用空格隔开</description>
    </item>
    
    <item>
      <title>2021-11-17</title>
      <link>https://zyooo.github.io/leetcodedairy/20211117/</link>
      <pubDate>Wed, 17 Nov 2021 12:15:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211117/</guid>
      <description>318.最大单词长度乘积 给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-of-word-lengths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处. 本来以为简简单单，结果发现看漏了题目中不含有公共字母的两个单词。然后感觉难度暴增，最后也是成功写出了屎一般的代码，11%+6%。看了题解之后学到了新的东西，思路其实差不多，最优的时间复杂度也是要O(n²)，但是在比较是否出现公共字母的时候，不想用int[26]去表示一个字符串出现过的字母，那样子空间和时间都花费很多，最后看了题解发现可以用掩码去解决，就是用一个int的低26位表示，效果和数组一样，而且比较只需要&amp;amp;运算就能算出，快太多了。
官方题解是将mask（掩码）作为map的key，length作为map的val，然后再去双重遍历keySet得出最大的答案。按照这个思路做了之后，还是不够快，最后去看高速度的题解，才发现有更快的方法！真是厉害，直接不用map，用于words长度相等的一个int[]去存放掩码，然后通过对应的数组下标可以直接得到words[i].length()空间上更加节省了，同时因为是有顺序去二重遍历的，所以一重循环i&amp;lt;words.length-1，而二重循环的ｊ的开始是ｉ＋１，因为在在前面ｉ的遍历中已经和当前ｊ匹配过了，所以无需再匹配了。
class Solution { public int maxProduct(String[] words) { int ans = 0; //words中每个string对应的掩码  int[] masks = new int[words.length]; for(int i = 0; i &amp;lt; words.length; i++){ for(char c : words[i].toCharArray()) masks[i] |= 1&amp;lt;&amp;lt;(c-&amp;#39;a&amp;#39;); } //二重遍历  for(int i = 0; i &amp;lt; words.length-1; i++){ for(int j = i+1; j &amp;lt; words.length; j++){ //字符串无公共字母  if((masks[i] &amp;amp; masks[j]) == 0) ans = Math.</description>
    </item>
    
    <item>
      <title>Day6-2021-11-15</title>
      <link>https://zyooo.github.io/leetcodedairy/20211115/</link>
      <pubDate>Mon, 15 Nov 2021 10:58:22 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211115/</guid>
      <description>319.灯泡开关 @脑筋急转弯
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。 找出并返回 n 轮后有多少个亮着的灯泡。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bulb-switcher 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 最开始模拟了整个过程,结果测试例子给个99999999,直接超出内存限制,感觉事情并不简单.
题解:
class Solution { public int bulbSwitch(int n) { return (int) Math.sqrt(n); } } /* 影响第x位灯泡的因素是他的约数 例如6, 约数为1,2,3,6 第一轮即点亮所有,2是关闭,3是点亮,最后6会关闭,所以有偶数个约数的位的灯泡最后都是关闭 所以只有奇数个约数的位最后才会被点亮,即为完全平方数 例如4,约数为1,2,4 n个数中,完全平方数的数量刚好为sqrt(n)向下取整 例如n=9,其中1,4,9为平方数,数量为sqrt(9) = 3 1&amp;lt;= x² &amp;lt;= n 1&amp;lt;= x &amp;lt;= sqrt(n) */ </description>
    </item>
    
    <item>
      <title>Tomcat</title>
      <link>https://zyooo.github.io/bugs/tomcat/</link>
      <pubDate>Wed, 10 Nov 2021 17:16:39 +0800</pubDate>
      
      <guid>https://zyooo.github.io/bugs/tomcat/</guid>
      <description>修改Tomcat的默认端口和启动项目 修改默认端口 1.首先查看80端口是否被占用
netstat -lntp | grep 80 2.进入tomcat安装目录下的conf文件夹修改server.xml文件
将端口修改为80
但是这个时候输入netstat -lntp | grep 80 查看发现只监听了 127.0.0.1:80 没有打开:::80,也就是0.0.0.0:80
导致外部无法访问80端口,最后重启了云服务器之后在查看发现可以了.
修改默认启动项目 在host下面添加 context的内容,docBase就是项目路径名称,默认的绝对路径是上面配置的name和appBase</description>
    </item>
    
    <item>
      <title>2021-11-05</title>
      <link>https://zyooo.github.io/leetcodedairy/20211105/</link>
      <pubDate>Fri, 05 Nov 2021 12:21:38 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211105/</guid>
      <description>重塑矩阵 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reshape-the-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 原本想的就是先判断面积是否相等,然后将速度按照rc去放入,但是赶着吃饭没想明白用取余的具体操作,就直接暴力了.
class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { if(r*c != mat.length*mat[0].length){ return mat; } int[] arr = new int[r*c]; int index = 0; for(int i = 0; i &amp;lt; mat.</description>
    </item>
    
    <item>
      <title>2021-11-04</title>
      <link>https://zyooo.github.io/leetcodedairy/20211104/</link>
      <pubDate>Thu, 04 Nov 2021 20:40:11 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211104/</guid>
      <description>两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 我的思路是先把一个数组存入hashmap中,用值来当key,value为这个数组中这个数字的出现次数,然后遍历第二个数组,当map中有这个值存在而且value大于0,就将这个值加入到list中,最后再将list转化为int[],但是不能直接转换成int[],只能直接转换成Integer[],所以就采用了遍历赋值的方法.
class Solution { public int[] intersect(int[] nums1, int[] nums2) { Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int x : nums1) { if(map.containsKey(x)){ map.put(x,map.get(x)+1); }else{ map.put(x,1); } } for(int x : nums2){ if(map.get(x) != null &amp;amp;&amp;amp; map.get(x) &amp;gt; 0){ list.</description>
    </item>
    
    <item>
      <title>2021-11-03</title>
      <link>https://zyooo.github.io/leetcodedairy/20211103/</link>
      <pubDate>Wed, 03 Nov 2021 19:59:17 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211103/</guid>
      <description>合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 使用双指针比较两数组尾,即排序后的最大数值,倒序放入nums1中,如果两个数组中的一个已经遍历完,则剩余的都为另一数组剩余的.
class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { //从尾部开始比谁大再放入tail指向的nums1中值  int p1 = m-1; int p2 = n-1; int tail = m+n-1; while(p2 &amp;gt;= 0 || p1 &amp;gt;= 0){ //m个已经全部放完,剩下的全部放nums2  if(p1 == -1){ nums1[tail--] = nums2[p2--]; }else if(p2 == -1){ nums1[tail--] = nums1[p1--]; }else if(nums2[p2] &amp;gt;= nums1[p1]){ nums1[tail--] = nums2[p2--]; }else{ nums1[tail--] = nums1[p1--]; } } } } 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>2021-10-31</title>
      <link>https://zyooo.github.io/leetcodedairy/20211031/</link>
      <pubDate>Sun, 31 Oct 2021 21:22:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211031/</guid>
      <description>最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 用贪心算法去解决此问题,遍历数组,得到当前的值,如果lastCount小于零的话就抛弃,当前和就等于当前值,如果lastCount大于等于0的话就和当前值相加作为当前和,lastCount等于当前和,当前和和最大和比较,得出最大和,遍历完一边之后返回最大和.
时间复杂度:O(n) 空间复杂度: O(1)
class Solution { public int maxSubArray(int[] nums) { int index = 0; int lastCount = 0; int maxCount = 0; for(int currentNum : nums){ int currentCount; if(index == 0){ index++; currentCount = currentNum; lastCount = currentCount; maxCount = currentCount; }else{ if(lastCount &amp;lt; 0){ currentCount = currentNum; maxCount = (maxCount &amp;gt; currentCount) ? maxCount : currentCount; lastCount = currentCount; }else{ currentCount = currentNum + lastCount; maxCount = (maxCount &amp;gt; currentCount) ?</description>
    </item>
    
    <item>
      <title>OralEnglish</title>
      <link>https://zyooo.github.io/note/oralenglish/</link>
      <pubDate>Wed, 20 Oct 2021 12:25:53 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/oralenglish/</guid>
      <description>Day 1 Success means different things for different people, some may equate it with fame, some with wealth and still some with accomplishments. For me, it means fulfilling one&amp;rsquo;s dreams. Whatever your dreams are, you have a goal and then focus all your attention on it.
Dreams bring you hope and happiness. In the process of struggling for it, you cry, sweat, complain or even purse,but the joy of harvesting makes you forget all the pains and troubles you have gone through.</description>
    </item>
    
    <item>
      <title>Nginx</title>
      <link>https://zyooo.github.io/javadairy/nginx/</link>
      <pubDate>Sun, 17 Oct 2021 19:29:27 +0800</pubDate>
      
      <guid>https://zyooo.github.io/javadairy/nginx/</guid>
      <description>*Nginx* *1.**课程目标* 目标1：掌握Nginx的安装
目标2：掌握Nginx的静态网站部署
目标3：理解Nginx的反向代理与负载均衡，能够配置反向代理与负载均衡
*2.Nginx的安装与启动* *2.1什么是Nginx* Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑 5 万并发链接，并且 cpu、内存等资源消耗却非常低，运行非常稳定。
*Nginx 应用场景：*
1、http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。
2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。
3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。
*2.2 Nginx在Linux下的安装* 重新准备一台虚拟机作为服务器。比如IP地址为192.168.177.129
*2.2.1环境准备* （1）需要安装 gcc 的环境【此步省略】
yum install gcc-c++
（2）第三方的开发包。
n *PCRE*
PCRE(Perl Compatible Regular Expressions)是一个 Perl 库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库。
yum install -y pcre pcre-devel
注：pcre-devel 是使用 pcre 开发的一个二次开发库。nginx 也需要此库。</description>
    </item>
    
    <item>
      <title>Linux</title>
      <link>https://zyooo.github.io/note/linux/</link>
      <pubDate>Sun, 17 Oct 2021 09:12:25 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/linux/</guid>
      <description>Linux学习 输入ifconfig 查询ip地址,以后用于远程连接,我的192.168.122.128,使用CRT去远程连接服务器.
常用命令 文件里有文档可以查
cd
pwd
li
li -a
li -l == ll
按tab可以补文件名称
cd .. 退回上一级
cd - 放回上一次的目录
mkdir 加上-p可以创建多级目录
rmdir 只能删除空文件
cat 查看全部
more 空格满屏 回车一行
less 上下键翻动 q退出
tail -f 动态查看实时监控
cp (copy) cp 文件名 粘贴的路径,可改名
mv (move)
./ 当前目录 ../上一级目录
rm 删除文件 回复y或者n
rm -r 删除文件夹
rm -rf 删除且不询问
rm -f * 删除所有文件
rm -f / root目录下所有文件*
tar 打包或者解压
【find】命令
find指令用于查找符合条件的文件
示例：
find / -name “ins*” 查找文件名称是以ins开头的文件</description>
    </item>
    
    <item>
      <title>travel</title>
      <link>https://zyooo.github.io/javadairy/example/</link>
      <pubDate>Wed, 13 Oct 2021 11:03:43 +0800</pubDate>
      
      <guid>https://zyooo.github.io/javadairy/example/</guid>
      <description>黑马旅游网案例 注册 &amp;lt;script&amp;gt; /* * 表单校验： * 1.用户名：单词字符，长度8到20位 * 2.密码：单词字符，长度8到20位 *	3.email：邮件格式 * 4.姓名：非空 * 5.手机号：手机号格式 *	6.出生日期：非空 *	7.验证码：非空 * */ function checkUsername(){ var username = $(&amp;quot;#username&amp;quot;).val(); var reg_username = /^\w{8,20}$/; var flag = reg_username.test(username); if(flag){ $(&amp;quot;#username&amp;quot;).css(&amp;quot;border&amp;quot;,&amp;quot;&amp;quot;); }else{ $(&amp;quot;#username&amp;quot;).css(&amp;quot;border&amp;quot;,&amp;quot;1px solid red&amp;quot;); } return flag; }	$(function (){ //表单提交时调用所有校验方法 $(&amp;quot;#registerForm&amp;quot;).submit(function (){ return checkUsername() &amp;amp;&amp;amp; checkPassword() &amp;amp;&amp;amp; checkEmail() &amp;amp;&amp;amp; checkName() &amp;amp;&amp;amp; checkTelephone() &amp;amp;&amp;amp; checkBirthday() &amp;amp;&amp;amp; checkCheck(); }); //组件失去焦点时，调用对应的校验方法 $(&amp;quot;#username&amp;quot;).blur(checkUsername); $(&amp;quot;#password&amp;quot;).blur(checkPassword);//注意这里的checkPassword不要加括号 $(&amp;quot;#email&amp;quot;).blur(checkEmail); $(&amp;quot;#name&amp;quot;).</description>
    </item>
    
    <item>
      <title>Cmd中mvn_compile出现的问题</title>
      <link>https://zyooo.github.io/bugs/cmd%E4%B8%ADmvn_compile%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sun, 10 Oct 2021 09:41:38 +0800</pubDate>
      
      <guid>https://zyooo.github.io/bugs/cmd%E4%B8%ADmvn_compile%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>在cmd上运行mvn compile时出现编译错误
No compiler is provided in this environment. Perhaps you are running on a JRE rather than a JDK?
输入mvn -v查看
查看环境变量
将JAVA_HOME路径修改为jdk的
重启cmd输入java -version检查是否配置成功
mvn -v
再次编译,成功</description>
    </item>
    
    <item>
      <title>Maven</title>
      <link>https://zyooo.github.io/javadairy/maven/</link>
      <pubDate>Sun, 10 Oct 2021 08:45:35 +0800</pubDate>
      
      <guid>https://zyooo.github.io/javadairy/maven/</guid>
      <description>Apache下的一个项目管理工具
官网地址 maven.apache.org
配置环境目录 1.获得maven文件夹的目录F:\software\apache-maven-3.8.3
2.在环境变量中新建一个新的 系统变量 , MAVEN_HOME ,将文件目录给放上去
3.在Path中新建一个 %MAVEN_HOME%\bin
完成,打开cmd mvn -v检查是否安装成功,注意如果一开始是有错误的,更正之后记得重新打开cmd
Maven仓库 Maven项目的仓库刚开始是没jar包的,当Maven项目需要jar包时先去查找本地仓库,如果没有再从中央仓库(由Maven团队设立的一个唯一的仓库)下载到本地仓库.
远程仓库好处:可先去获取中央仓库中的jar包,提高本地仓库获取的速度,也可以放置一些公司自己写的jar包.
cmd中在Maven项目的目录下mvn compile创建默认位置本地仓库
修改本地仓库位置 打开maven目录下的conf目录下的setting.xml
&amp;lt;localRepository&amp;gt;/path/to/local/repo&amp;lt;/localRepository&amp;gt; 修改为想要的路径,例如 &amp;lt;localRepository&amp;gt;F:\software\apache-maven-3.8.3\mvn_repository&amp;lt;/localRepository&amp;gt; 再加入配置文件中 访问中央仓库太慢的话,课访问国内的私服,例如阿里云的私服
	配置到setting.xml里面mirror部分 &amp;lt;mirror&amp;gt; &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt; &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt; &amp;lt;/mirror&amp;gt; 目录结构 ![](https://i.loli.net/2021/10/10/xeV6EHDjUpTdqG9.png
常用命令 mvn compile
​	编译出字节码文件,在target目录下
mvn clean
​	删除target目录
mvn package
​	对于 java 工程执行 package 打成 jar 包，对于 web 工程打成 war包,同时先编译了。
mvn install
​	本地的当前项目安装到本地仓库中
生命周期 maven 对项目构建过程分为三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”，这三套生命周期分别是：
Clean Lifecycle 在进行真正的构建之前进行一些清理工作。</description>
    </item>
    
    <item>
      <title>Ideal2021JavaWeb项目配置</title>
      <link>https://zyooo.github.io/note/ideal2021javaweb%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Sat, 09 Oct 2021 12:28:42 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/ideal2021javaweb%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/</guid>
      <description>Itellidea2021版本中web项目的配置
右键项目名称，选择Add Frameworks Support，勾选Web Application，OK。
添加Tomcat
点右上角
或者菜单栏中Run中的Edit Configurations
这个自己配置
回到打开project structure –&amp;gt; Modules
选择添加library
添加Tomcat包之后选择web，勾选下方的SourceRoots，这样才能直接new servlet
注意重启idea后这个勾会没打上，所以要自己打上</description>
    </item>
    
    <item>
      <title>Windows下redis-Server秒退</title>
      <link>https://zyooo.github.io/bugs/windows%E4%B8%8Bredi-server.exe%E7%A7%92%E9%80%80/</link>
      <pubDate>Sat, 09 Oct 2021 11:49:46 +0800</pubDate>
      
      <guid>https://zyooo.github.io/bugs/windows%E4%B8%8Bredi-server.exe%E7%A7%92%E9%80%80/</guid>
      <description>Windows下redi-server.exe秒退 遇到个问题： 在第一次正常启动之后，配置完conf里的save，再次开启server秒退。
错误信息：QForkMasterInit: system error caught. error code=0x000005af, message=VirtualAllocEx failed.: unknown error
**原因：**未设置redis最大内存
**解决：**在conf中最下面加入
maxmemory 268435456 maxheap 314572800 再次启动正常 在目录下打开cmd 输入 redis-server.exe redis.windows.conf</description>
    </item>
    
    <item>
      <title>Redis&amp;Jedis</title>
      <link>https://zyooo.github.io/javadairy/redisjedis/</link>
      <pubDate>Sat, 09 Oct 2021 11:46:30 +0800</pubDate>
      
      <guid>https://zyooo.github.io/javadairy/redisjedis/</guid>
      <description>redis&amp;amp;Jedis redis 概念：一款高性能的NOSQL系列的非关系型数据库
关系型数据库：MySQL、Oracle…
​	使用表单存储数据，数据之间有关联关系，数据存储在硬盘的文件上
非关系型数据库(NOSQL): redis, hbase…
​	使用键值对去存储数据，数据之间没有关联关系，数据存储在内存中
两种数据库并非对立而是互补，关系型用来做数据库，NOSQL用于做缓存、秒杀任务队列、网站访问统计等
去https://redis.io官网下载的只有Linux系统的redis，先用着黑马的Windows绿色版本，等后边部署Linux的时候再使用
key，value； 其中key都是字符串，value有5种不同的数据结构
value：
​	1.字符串类型string
​	2.哈希类型hash：map格式
​	3.列表类型list： linkedlist格式
​	4.集合类型set
​	5.有序集合类型sortedset
**命令操作 ** (更多详细的操作在redis官网文档中有)
字符串类型 string
1. 存储： set key value 127.0.0.1:6379&amp;gt; set username zhangsan OK 2. 获取： get key 127.0.0.1:6379&amp;gt; get username &amp;quot;zhangsan&amp;quot; 3. 删除： del key 127.0.0.1:6379&amp;gt; del age (integer) 1  哈希类型 hash
  存储： hset key field value 127.0.0.1:6379&amp;gt; hset myhash username lisi (integer) 1 127.</description>
    </item>
    
    <item>
      <title>2021.10.08</title>
      <link>https://zyooo.github.io/leetcodedairy/20211008/</link>
      <pubDate>Sat, 09 Oct 2021 11:35:50 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211008/</guid>
      <description>1.旅行终点站 简单 2021.10.08 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
解题的思路就是遍历一遍paths，取cityB，第二重遍历取cityA，当第二重遍历的cityA等于第一重遍历的cityB时说明这条路线是有出路的，反之当第二重遍历结束后依然没有对应的cityA，说明此时第一重遍历的cityB即为终点。
但是实现方式过于单一，没有去向其他更快捷的方式，导致速度太慢，参考官方题解当中，利用哈希表HashSet去储存一组需要遍历的量，提高速度。
class Solution { public String destCity(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { for(int i=0; i&amp;lt;paths.size(); i++){ for(int j=0; j&amp;lt;paths.size(); j++){ if(i!=j &amp;amp;&amp;amp; paths.get(i).get(1).equals(paths.get(j).get(0))){ break; }else if(j==paths.size()-1){ return paths.get(i).get(1); } } } return &amp;#34;&amp;#34;; } } //官方题解 class Solution { public String destCity(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { Set&amp;lt;String&amp;gt; citiesA = new HashSet&amp;lt;String&amp;gt;(); for (List&amp;lt;String&amp;gt; path : paths) { citiesA.add(path.get(0)); } for (List&amp;lt;String&amp;gt; path : paths) { if (!</description>
    </item>
    
    <item>
      <title>BigTalkDesignPattenNote</title>
      <link>https://zyooo.github.io/note/bigtalkdesignpattennote/</link>
      <pubDate>Fri, 08 Oct 2021 14:23:01 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/bigtalkdesignpattennote/</guid>
      <description>大话设计模式读书笔记 1.简单工厂模式 用一个单独的类来做创照实例的过程，这就是工厂
public class OperationFactory{ public static Operation createOperate(string operate){ Operation oper = null; switch(operate){ case &amp;quot;+&amp;quot;: oper = new OperationAdd(); break; case &amp;quot;-&amp;quot;: oper = new OperationSub(); break; case &amp;quot;*&amp;quot;: oper = new OperationMul(); break; case &amp;quot;/&amp;quot;: oper = new OperationMul(); break; } return oper; } } Operation oper; oper = OperationFactory.createOperate(&amp;quot;+&amp;quot;); oper.NumberA = 1; oper.NumberB = 2; double result = oper.GetResult(); *UML类图 UML类图图示样例
类图 类图分为三层
第一层显示类的名称，如果是抽象类，则就用斜体显示。
第二层是类的特性，通常就是字段和属性。</description>
    </item>
    
    <item>
      <title>如何添加右键可选在此处打开命令行窗口</title>
      <link>https://zyooo.github.io/note/note1/</link>
      <pubDate>Fri, 01 Oct 2021 10:05:28 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/note1/</guid>
      <description>如何添加右键可选在此处打开命令行窗口 1.win+r 输入 regedit 回车打开注册表 2.切换到HKEY_CLASSES_ROOT\Directory\Background\shell\ 右键shell，新建项 “OpenCMDHere” 并在该项下，右击新建项 “command” 直接点击OpenCMDHere将OpenCMDHere中的默认改为 在此处打开命令窗口 右键 新建字符串名，名字为Icon将值改为cmd.exe 创建 OpenCMDHere 的图片 3.修改command最终的默认值 输入 cmd.exe /s /k pushd \&amp;quot;%V\&amp;quot; </description>
    </item>
    
    <item>
      <title>Project</title>
      <link>https://zyooo.github.io/post/project/</link>
      <pubDate>Thu, 30 Sep 2021 17:16:46 +0800</pubDate>
      
      <guid>https://zyooo.github.io/post/project/</guid>
      <description>web尽快过完一遍,直接进入后端框架的学习,做一些SSM框架的东西 基础: 算法, 计网TCP/IP HTTP UDP 等协议, 操作系统, MySQL, 设计模式, Linux基础命令 java: 复习多线程Thread,Runnable, Callable, 池化技术,JVM MySQL的进阶 重点查看索引,事务这方面 《自顶向下计算机网络》《图解HTTP》《mysql技术内幕InnoDB储存引擎》 Redis也要学习 《Redis设计与实现(第二版)》 《大话设计模式》 《鸟哥的Linux私房菜》 《java核心技术卷一》《深入理解java虚拟机》(2,3,6,7章) 《实战java高并发程序设计》《java并发编程的艺术》 每天都需要学习的:
​	java后端知识, CET6, 算法
分阶段去学习的:
​	MySQL强化 java进阶 项目 设计模式 计算机网络 Linux
   任务  途径 每个部分都要写博客记录技术要点     java  先跟着黑马web看完把项目案例做完, 然后转向后端框架的学习   算法  算法第四版配上PTA使用, 后期刷LeetCode和面试题   项目  在项目中去学习MySQL进阶和Linux常用指令集   JVM  看书   计网  看书   设计模式  看书    </description>
    </item>
    
    <item>
      <title>Blog搭建和我的信息</title>
      <link>https://zyooo.github.io/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 30 Sep 2021 10:03:39 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/blog%E6%90%AD%E5%BB%BA%E5%92%8C%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF/</guid>
      <description>blog搭建和我的信息 现在已经安装好了hugo 在cmd中输入 hugo version可以查询
创建启动 hugo new site [path] [flags] 创建
这里是新创建了一个hugo new site F:\myblog blog
到 themes.gohugo.io里面去下载主题直接在cmd中clone
cd [path]
git clone https://github.com/vaga/hugo-theme-m10c.git themes/m10c
然后启动 hugo server -t m10c &amp;ndash;buildDrafts
Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)
通过本地链接就可以访问了
写一篇文章 hugo new post/hello.md
git 令牌
生成public文件夹 hugo --theme=m10c --baseUrl=&amp;#34;https://zyooo.github.io/&amp;#34; --buildDrafts 每一次添加东西先生成然后commit push
git操作 到public目录下
git add .
git commit -m&amp;rdquo; &amp;quot;
git push origin main</description>
    </item>
    
    <item>
      <title>Vocabulary</title>
      <link>https://zyooo.github.io/note/note/</link>
      <pubDate>Wed, 29 Sep 2021 19:08:46 +0800</pubDate>
      
      <guid>https://zyooo.github.io/note/note/</guid>
      <description>2021.09.27           flatter vt.奉承;自命不凡,使显得更漂亮   thrift n.节约,节俭; 海石竹   contrast n.差异,悬殊;截然不同的实物; vt.对照,对比. vi.有明显差异   pharmacy n.药房,药店;药剂学;配药学   pilgrim n.朝圣者,香客;清教徒前辈移民   glacier n.冰川，冰河   cholesterol n.胆固醇   asylum n.(政治)避难,庇护   corporal n.下士.adj.肉体的,身体的   gauge n.测量仪器,宽度,口径; vt.判断,测量,估算   prosper vi.繁荣,兴旺,发达   surgery n.外科手术;手术室;应诊时间   contingent 依情况而定的,n.代表团   corporate adj.公司的 ; 团体的   collaboration n.</description>
    </item>
    
  </channel>
</rss>
