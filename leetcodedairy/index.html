<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>LeetCodeDairies | Ray</title>
<meta name="keywords" content="" />
<meta name="description" content="LeetCodeDairies - Ray">
<meta name="author" content="Ray">
<link rel="canonical" href="https://zyooo.github.io/leetcodedairy/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.61dfb3f0b4cda95d2ccb867f9a3b244ce5d23e12492bcc3c277df594c7bc1adf.css" integrity="sha256-Yd&#43;z8LTNqV0sy4Z/mjskTOXSPhJJK8w8J331lMe8Gt8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://zyooo.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zyooo.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zyooo.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zyooo.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://zyooo.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.70.0" />
<link rel="alternate" type="application/rss+xml" href="https://zyooo.github.io/leetcodedairy/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="LeetCodeDairies" />
<meta property="og:description" content="What everyonne you can do,just do it." />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://zyooo.github.io/leetcodedairy/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LeetCodeDairies"/>
<meta name="twitter:description" content="What everyonne you can do,just do it."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "LeetCodeDairies",
      "item": "https://zyooo.github.io/leetcodedairy/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zyooo.github.io/" accesskey="h" title="Ray (Alt + H)">Ray</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zyooo.github.io/note/" title="NOTE">
                    <span>NOTE</span>
                </a>
            </li>
            <li>
                <a href="https://zyooo.github.io/leetcodedairy/" title="LeetCodeDairy">
                    <span class="active">LeetCodeDairy</span>
                </a>
            </li>
            <li>
                <a href="https://zyooo.github.io/bugs/" title="Bugs">
                    <span>Bugs</span>
                </a>
            </li>
            <li>
                <a href="https://zyooo.github.io/javadairy/" title="JavaDairy">
                    <span>JavaDairy</span>
                </a>
            </li>
            <li>
                <a href="https://zyooo.github.io/golangdairy/" title="GolangDairy">
                    <span>GolangDairy</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>LeetCodeDairies</h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Day7-2021-11-17<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <section class="entry-content">
    <p>318.最大单词长度乘积 给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-of-word-lengths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处. 本来以为简简单单，结果发现看漏了题目中不含有公共字母的两个单词。然后感觉难度暴增，最后也是成功写出了屎一般的代码，11%&#43;6%。看了题解之后学到了新的东西，思路其实差不多，最优的时间复杂度也是要O(n²)，但是在比较是否出现公共字母的时候，不想用int[26]去表示一个字符串出现过的字母，那样子空间和时间都花费很多，最后看了题解发现可以用掩码去解决，就是用一个int的低26位表示，效果和数组一样，而且比较只需要&amp;运算就能算出，快太多了。
官方题解是将mask（掩码）作为map的key，length作为map的val，然后再去双重遍历keySet得出最大的答案。按照这个思路做了之后，还是不够快，最后去看高速度的题解，才发现有更快的方法！真是厉害，直接不用map，用于words长度相等的一个int[]去存放掩码，然后通过对应的数组下标可以直接得到words[i].length()空间上更加节省了，同时因为是有顺序去二重遍历的，所以一重循环i&lt;words.length-1，而二重循环的ｊ的开始是ｉ＋１，因为在在前面ｉ的遍历中已经和当前ｊ匹配过了，所以无需再匹配了。
class Solution { public int maxProduct(String[] words) { int ans = 0; //words中每个string对应的掩码  int[] masks = new int[words.length]; for(int i = 0; i &lt; words.length; i&#43;&#43;){ for(char c : words[i].toCharArray()) masks[i] |= 1&lt;&lt;(c-&#39;a&#39;); } //二重遍历  for(int i = 0; i &lt; words.length-1; i&#43;&#43;){ for(int j = i&#43;1; j &lt; words.length; j&#43;&#43;){ //字符串无公共字母  if((masks[i] &amp; masks[j]) == 0) ans = Math....</p>
  </section>
  <footer class="entry-footer"><span title='2021-11-17 12:15:12 +0800 CST'>November 17, 2021</span>&nbsp;·&nbsp;Ray</footer>
  <a class="entry-link" aria-label="post link to Day7-2021-11-17" href="https://zyooo.github.io/leetcodedairy/20211117/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Day6-2021-11-15<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <section class="entry-content">
    <p>319.灯泡开关 @脑筋急转弯
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。 找出并返回 n 轮后有多少个亮着的灯泡。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bulb-switcher 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 最开始模拟了整个过程,结果测试例子给个99999999,直接超出内存限制,感觉事情并不简单.
题解:
class Solution { public int bulbSwitch(int n) { return (int) Math.sqrt(n); } } /* 影响第x位灯泡的因素是他的约数 例如6, 约数为1,2,3,6 第一轮即点亮所有,2是关闭,3是点亮,最后6会关闭,所以有偶数个约数的位的灯泡最后都是关闭 所以只有奇数个约数的位最后才会被点亮,即为完全平方数 例如4,约数为1,2,4 n个数中,完全平方数的数量刚好为sqrt(n)向下取整 例如n=9,其中1,4,9为平方数,数量为sqrt(9) = 3 1&lt;= x² &lt;= n 1&lt;= x &lt;= sqrt(n) */ </p>
  </section>
  <footer class="entry-footer"><span title='2021-11-15 10:58:22 +0800 CST'>November 15, 2021</span>&nbsp;·&nbsp;Ray</footer>
  <a class="entry-link" aria-label="post link to Day6-2021-11-15" href="https://zyooo.github.io/leetcodedairy/20211115/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Day5-2021-11-05<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <section class="entry-content">
    <p>重塑矩阵 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reshape-the-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 原本想的就是先判断面积是否相等,然后将速度按照rc去放入,但是赶着吃饭没想明白用取余的具体操作,就直接暴力了.
class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { if(r*c != mat.length*mat[0].length){ return mat; } int[] arr = new int[r*c]; int index = 0; for(int i = 0; i &lt; mat....</p>
  </section>
  <footer class="entry-footer"><span title='2021-11-05 12:21:38 +0800 CST'>November 5, 2021</span>&nbsp;·&nbsp;Ray</footer>
  <a class="entry-link" aria-label="post link to Day5-2021-11-05" href="https://zyooo.github.io/leetcodedairy/20211105/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Day4-2021-11-04<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <section class="entry-content">
    <p>两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 我的思路是先把一个数组存入hashmap中,用值来当key,value为这个数组中这个数字的出现次数,然后遍历第二个数组,当map中有这个值存在而且value大于0,就将这个值加入到list中,最后再将list转化为int[],但是不能直接转换成int[],只能直接转换成Integer[],所以就采用了遍历赋值的方法.
class Solution { public int[] intersect(int[] nums1, int[] nums2) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int x : nums1) { if(map.containsKey(x)){ map.put(x,map.get(x)&#43;1); }else{ map.put(x,1); } } for(int x : nums2){ if(map.get(x) != null &amp;&amp; map.get(x) &gt; 0){ list....</p>
  </section>
  <footer class="entry-footer"><span title='2021-11-04 20:40:11 +0800 CST'>November 4, 2021</span>&nbsp;·&nbsp;Ray</footer>
  <a class="entry-link" aria-label="post link to Day4-2021-11-04" href="https://zyooo.github.io/leetcodedairy/20211104/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Day3-2021-11-03<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <section class="entry-content">
    <p>合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m &#43; n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 使用双指针比较两数组尾,即排序后的最大数值,倒序放入nums1中,如果两个数组中的一个已经遍历完,则剩余的都为另一数组剩余的.
class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { //从尾部开始比谁大再放入tail指向的nums1中值  int p1 = m-1; int p2 = n-1; int tail = m&#43;n-1; while(p2 &gt;= 0 || p1 &gt;= 0){ //m个已经全部放完,剩下的全部放nums2  if(p1 == -1){ nums1[tail--] = nums2[p2--]; }else if(p2 == -1){ nums1[tail--] = nums1[p1--]; }else if(nums2[p2] &gt;= nums1[p1]){ nums1[tail--] = nums2[p2--]; }else{ nums1[tail--] = nums1[p1--]; } } } } 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] &#43; nums[1] == 9 ，返回 [0, 1] 。 来源：力扣（LeetCode） 链接：https://leetcode-cn....</p>
  </section>
  <footer class="entry-footer"><span title='2021-11-03 19:59:17 +0800 CST'>November 3, 2021</span>&nbsp;·&nbsp;Ray</footer>
  <a class="entry-link" aria-label="post link to Day3-2021-11-03" href="https://zyooo.github.io/leetcodedairy/20211103/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Day2-2021-10-31<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <section class="entry-content">
    <p>最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 用贪心算法去解决此问题,遍历数组,得到当前的值,如果lastCount小于零的话就抛弃,当前和就等于当前值,如果lastCount大于等于0的话就和当前值相加作为当前和,lastCount等于当前和,当前和和最大和比较,得出最大和,遍历完一边之后返回最大和.
时间复杂度:O(n) 空间复杂度: O(1)
class Solution { public int maxSubArray(int[] nums) { int index = 0; int lastCount = 0; int maxCount = 0; for(int currentNum : nums){ int currentCount; if(index == 0){ index&#43;&#43;; currentCount = currentNum; lastCount = currentCount; maxCount = currentCount; }else{ if(lastCount &lt; 0){ currentCount = currentNum; maxCount = (maxCount &gt; currentCount) ? maxCount : currentCount; lastCount = currentCount; }else{ currentCount = currentNum &#43; lastCount; maxCount = (maxCount &gt; currentCount) ?...</p>
  </section>
  <footer class="entry-footer"><span title='2021-10-31 21:22:51 +0800 CST'>October 31, 2021</span>&nbsp;·&nbsp;Ray</footer>
  <a class="entry-link" aria-label="post link to Day2-2021-10-31" href="https://zyooo.github.io/leetcodedairy/20211031/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>2021.10.08<sup><span class="entry-isdraft">&nbsp;&nbsp;[draft]</span></sup>
    </h2>
  </header>
  <section class="entry-content">
    <p>1.旅行终点站 简单 2021.10.08 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
解题的思路就是遍历一遍paths，取cityB，第二重遍历取cityA，当第二重遍历的cityA等于第一重遍历的cityB时说明这条路线是有出路的，反之当第二重遍历结束后依然没有对应的cityA，说明此时第一重遍历的cityB即为终点。
但是实现方式过于单一，没有去向其他更快捷的方式，导致速度太慢，参考官方题解当中，利用哈希表HashSet去储存一组需要遍历的量，提高速度。
class Solution { public String destCity(List&lt;List&lt;String&gt;&gt; paths) { for(int i=0; i&lt;paths.size(); i&#43;&#43;){ for(int j=0; j&lt;paths.size(); j&#43;&#43;){ if(i!=j &amp;&amp; paths.get(i).get(1).equals(paths.get(j).get(0))){ break; }else if(j==paths.size()-1){ return paths.get(i).get(1); } } } return &#34;&#34;; } } //官方题解 class Solution { public String destCity(List&lt;List&lt;String&gt;&gt; paths) { Set&lt;String&gt; citiesA = new HashSet&lt;String&gt;(); for (List&lt;String&gt; path : paths) { citiesA.add(path.get(0)); } for (List&lt;String&gt; path : paths) { if (!...</p>
  </section>
  <footer class="entry-footer"><span title='2021-10-09 11:35:50 +0800 CST'>October 9, 2021</span>&nbsp;·&nbsp;Ray</footer>
  <a class="entry-link" aria-label="post link to 2021.10.08" href="https://zyooo.github.io/leetcodedairy/20211008/"></a>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2021 <a href="https://zyooo.github.io/">Ray</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
