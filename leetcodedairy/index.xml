<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCodeDairies on JoyBoy&#39;s blog</title>
    <link>https://zyooo.github.io/leetcodedairy/</link>
    <description>Recent content in LeetCodeDairies on JoyBoy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy; 2021 &lt;a href=&#34;https://www.wangchucheng.com/&#34;&gt;WANG Chucheng&lt;/a&gt; and &lt;a href=&#34;https://www.ruiqima.com/&#34;&gt;MA Ruiqi&lt;/a&gt;
</copyright>
    <lastBuildDate>Mon, 28 Feb 2022 07:50:01 +0800</lastBuildDate><atom:link href="https://zyooo.github.io/leetcodedairy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2022-02-28</title>
      <link>https://zyooo.github.io/leetcodedairy/20220228/</link>
      <pubDate>Mon, 28 Feb 2022 07:50:01 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220228/</guid>
      <description>1601.最多可达成的换楼请求目的 hard 对于每个选择, 都有选或者不选两个操作, delta数组记录每栋楼的员工变化量, 以及变量cnt记录被选择的请求数量, 如果选择当前请求, delta[x]值减1, delta[y]加1, 不选择则不做操作, 枚举完了之后判断delta中所有值是否为0, 并且根据cnt和res大小更新答案.</description>
    </item>
    
    <item>
      <title>第282场周赛T3</title>
      <link>https://zyooo.github.io/leetcodedairy/20220227/</link>
      <pubDate>Sun, 27 Feb 2022 17:28:07 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220227/</guid>
      <description>这道题用O(N^2)的解法会超时, 所以要想办法降低时间复杂度, 所以使用二分法, 但是这里二分的不是time数组, 而是时间, 而时间的区间如何取定呢, 先把time升序排序, 然后最短的可能是1s, 最长的时间可能是time[0] * totoalTrips, 所以就可以采用二分法了</description>
    </item>
    
    <item>
      <title>2022-02-24</title>
      <link>https://zyooo.github.io/leetcodedairy/20220224/</link>
      <pubDate>Thu, 24 Feb 2022 21:54:42 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220224/</guid>
      <description>开始是直接遍历的方法得到数字, 后来想着如果是严格按照一个形式的话, 那么 一个复数中只会出现一个 &amp;lsquo;+&amp;rsquo;
并且将虚部和实部分割, 可以利用这个去直接得到abcd, 不过不知道底层代码, 估计速度也是差不多的
代码: 100% 100%</description>
    </item>
    
    <item>
      <title>2022-02-08</title>
      <link>https://zyooo.github.io/leetcodedairy/20220208/</link>
      <pubDate>Sun, 20 Feb 2022 20:07:20 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220208/</guid>
      <description>1001.网格照明 hard 2022.02.08 数据规模太大了, 原本想着硬模拟的后来还是放弃了
打算用map去存储行列和两个对角的情况, 但是又不知道怎么去表示同一条对角
官方题解:
func gridIllumination(n int, lamps, queries [][]int) []int { type pair struct{ x, y int } points := map[pair]bool{} row := map[int]int{} col := map[int]int{} diagonal := map[int]int{} antiDiagonal := map[int]int{} for _, lamp := range lamps { r, c := lamp[0], lamp[1] p := pair{r, c} if points[p] { continue } points[p] = true row[r]++ col[c]++ //用这个来表示哪条对角, 妙啊 diagonal[r-c]++ antiDiagonal[r+c]++ } ans := make([]int, len(queries)) for i, query := range queries { r, c := query[0], query[1] if row[r] &amp;gt; 0 || col[c] &amp;gt; 0 || diagonal[r-c] &amp;gt; 0 || antiDiagonal[r+c] &amp;gt; 0 { ans[i] = 1 } for x := r - 1; x &amp;lt;= r+1; x++ { for y := c - 1; y &amp;lt;= c+1; y++ { if x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= n || !</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220109/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:58 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220109/</guid>
      <description>田忌赛马,打不过就送人头 代码逻辑
n := len(nums1) sort.Ints(nums1) //田忌的马 sort.Ints(nums2) //齐王的马 for i := n-1; i &amp;gt;= 0; i-- { if nums1[i] &amp;gt; nums2[i] { //比得过跟他比 } else { //比不过,换的垫底的来送人头 } } int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220108/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:54 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220108/</guid>
      <description>滑动窗口问题 int left = 0, right = 0 for right &amp;lt; len(s) { //增大窗口 window.</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220107/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220107/</guid>
      <description>二分搜索 //搜素左侧边界 func left_bound(nums []int, target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩右侧边界 right = mid }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 2 //搜索右侧边界 func right_bound(nums int[], target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩左侧边界 left = mid + 1 }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 4  技巧: 从题目中抽象出一个自变量x , 一个关于x的函数f(x), 以及一个目标值 target , 同时还要满足以下条件 : 1.</description>
    </item>
    
    <item>
      <title>2022-01-06</title>
      <link>https://zyooo.github.io/leetcodedairy/20220106/</link>
      <pubDate>Thu, 06 Jan 2022 11:18:06 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220106/</guid>
      <description>15.三数之和 穷举,确定了第一个数字之后, 剩下两个数字就是 target = target - nums[i] 的twoSum问题
func twoSumTarget2(nums []int, start, target int) [][]int { var ans [][]int //sort.</description>
    </item>
    
    <item>
      <title>2022-01-05</title>
      <link>https://zyooo.github.io/leetcodedairy/20220105/</link>
      <pubDate>Wed, 05 Jan 2022 07:49:09 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220105/</guid>
      <description>1576.替换所有的问号 func modifyString(s string) string { data := []byte(s) for i := 0; i &amp;lt; len(data); i++ { if data[i] == &#39;?</description>
    </item>
    
    <item>
      <title>2022-01-04</title>
      <link>https://zyooo.github.io/leetcodedairy/20220104/</link>
      <pubDate>Tue, 04 Jan 2022 07:46:10 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220104/</guid>
      <description>19.删除链表的倒数第N个节点 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := new(ListNode) dummy.</description>
    </item>
    
    <item>
      <title>2022-01-03</title>
      <link>https://zyooo.github.io/leetcodedairy/20220103/</link>
      <pubDate>Mon, 03 Jan 2022 18:29:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220103/</guid>
      <description>1185.一周中的第几天 难度简单92
给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
输入为三个整数：day、month 和 year，分别表示日、月、年。
您返回的结果必须是这几个值中的一个 {&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;}。</description>
    </item>
    
    <item>
      <title>2021-11-17</title>
      <link>https://zyooo.github.io/leetcodedairy/20211117/</link>
      <pubDate>Wed, 17 Nov 2021 12:15:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211117/</guid>
      <description>318.最大单词长度乘积 给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-of-word-lengths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处.</description>
    </item>
    
    <item>
      <title>Day6-2021-11-15</title>
      <link>https://zyooo.github.io/leetcodedairy/20211115/</link>
      <pubDate>Mon, 15 Nov 2021 10:58:22 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211115/</guid>
      <description>319.灯泡开关 @脑筋急转弯
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。 找出并返回 n 轮后有多少个亮着的灯泡。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>2021-11-05</title>
      <link>https://zyooo.github.io/leetcodedairy/20211105/</link>
      <pubDate>Fri, 05 Nov 2021 12:21:38 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211105/</guid>
      <description>重塑矩阵 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>2021-11-04</title>
      <link>https://zyooo.github.io/leetcodedairy/20211104/</link>
      <pubDate>Thu, 04 Nov 2021 20:40:11 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211104/</guid>
      <description>两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>2021-11-03</title>
      <link>https://zyooo.github.io/leetcodedairy/20211103/</link>
      <pubDate>Wed, 03 Nov 2021 19:59:17 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211103/</guid>
      <description>合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</description>
    </item>
    
    <item>
      <title>2021-10-31</title>
      <link>https://zyooo.github.io/leetcodedairy/20211031/</link>
      <pubDate>Sun, 31 Oct 2021 21:22:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211031/</guid>
      <description>最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。  用贪心算法去解决此问题,遍历数组,得到当前的值,如果lastCount小于零的话就抛弃,当前和就等于当前值,如果lastCount大于等于0的话就和当前值相加作为当前和,lastCount等于当前和,当前和和最大和比较,得出最大和,遍历完一边之后返回最大和.</description>
    </item>
    
    <item>
      <title>2021.10.08</title>
      <link>https://zyooo.github.io/leetcodedairy/20211008/</link>
      <pubDate>Sat, 09 Oct 2021 11:35:50 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211008/</guid>
      <description>1.旅行终点站 简单 2021.10.08 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。</description>
    </item>
    
  </channel>
</rss>
