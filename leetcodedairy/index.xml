<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCodeDairies on LoveIt</title>
    <link>https://zyooo.github.io/leetcodedairy/</link>
    <description>Recent content in LeetCodeDairies on LoveIt</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Mon, 28 Feb 2022 07:50:01 +0800</lastBuildDate>
    
	<atom:link href="https://zyooo.github.io/leetcodedairy/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>2022-02-28</title>
      <link>https://zyooo.github.io/leetcodedairy/20220228/</link>
      <pubDate>Mon, 28 Feb 2022 07:50:01 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220228/</guid>
      <description>1601.最多可达成的换楼请求目的 hard 对于每个选择, 都有选或者不选两个操作, delta数组记录每栋楼的员工变化量, 以及变量cnt记录被选择的请求数量, 如果选择当前请求, delta[x]值减1, delta[y]加1, 不选择则不做操作, 枚举完了之后判断delta中所有值是否为0, 并且根据cnt和res大小更新答案.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  func maximumRequests(n int, requests [][]int) int { res := 0 delta := make([]int,n) cnt,res,zero,l := 0,0,n,len(requests) var dfs func(pos int) dfs = func(pos int){ if pos == l { if zero == n &amp;amp;&amp;amp; cnt &amp;gt; res { res = cnt } return } //not  dfs(pos+1) //chose  z := zero cnt++ x,y := requests[pos][0],requests[pos][1] //减少之前  if delta[x] == 0 { zero-- } delta[x]-- //减少之后  if delta[x] == 0 { zero++ } if delta[y] == 0 { zero-- } delta[y]++ if delta[y] == 0 { zero++ } dfs(pos+1) delta[x]++ delta[y]-- cnt-- zero = z } dfs(0) return res }   </description>
    </item>
    
    <item>
      <title>第282场周赛T3</title>
      <link>https://zyooo.github.io/leetcodedairy/20220227/</link>
      <pubDate>Sun, 27 Feb 2022 17:28:07 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220227/</guid>
      <description>这道题用O(N^2)的解法会超时, 所以要想办法降低时间复杂度, 所以使用二分法, 但是这里二分的不是time数组, 而是时间, 而时间的区间如何取定呢, 先把time升序排序, 然后最短的可能是1s, 最长的时间可能是time[0] * totoalTrips, 所以就可以采用二分法了
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  func minimumTime(time []int, totalTrips int) int64 { sort.Ints(time) var left,right int64 = 1,int64(time[0]*totalTrips) n := len(time) for left &amp;lt; right { var tmp int64= 0 mid := left + (right-left)&amp;gt;&amp;gt;1 for i := 0; i &amp;lt; n &amp;amp;&amp;amp; int64(time[i]) &amp;lt;= mid; i++ { tmp += mid/int64(time[i]) } //左搜索, 右收缩  if tmp &amp;gt;= int64(totalTrips) { right = mid } else { left = mid+1 } } return left }   </description>
    </item>
    
    <item>
      <title>2022-02-24</title>
      <link>https://zyooo.github.io/leetcodedairy/20220224/</link>
      <pubDate>Thu, 24 Feb 2022 21:54:42 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220224/</guid>
      <description>开始是直接遍历的方法得到数字, 后来想着如果是严格按照一个形式的话, 那么 一个复数中只会出现一个 &amp;lsquo;+&amp;rsquo;
并且将虚部和实部分割, 可以利用这个去直接得到abcd, 不过不知道底层代码, 估计速度也是差不多的
代码: 100% 100%
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  func complexNumberMultiply(num1 string, num2 string) string { a,b := parse(num1) c,d := parse(num2) return fmt.Sprintf(&amp;#34;%v+%vi&amp;#34;,(a*c-b*d),(a*d+b*c)) } func parse (num string)(int,int){ a,b := 0,0 i,fa,fb := 0,1,1 flag := true n := len(num) if num[0] == &amp;#39;-&amp;#39; { fa = -1 i = 1 } for ;i &amp;lt; n; i++{ if num[i] &amp;gt;= &amp;#39;0&amp;#39; &amp;amp;&amp;amp; num[i] &amp;lt;= &amp;#39;9&amp;#39;{ if flag { a = a*10 + int(num[i] - &amp;#39;0&amp;#39;) } else { b = b*10 + int(num[i] - &amp;#39;0&amp;#39;) } } if num[i] == &amp;#39;+&amp;#39; { flag = false } else if num[i] == &amp;#39;-&amp;#39; { flag = false fb = -1 } } return a*fa,b*fb }   代码:100% 94%</description>
    </item>
    
    <item>
      <title>2022-02-08</title>
      <link>https://zyooo.github.io/leetcodedairy/20220208/</link>
      <pubDate>Sun, 20 Feb 2022 20:07:20 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220208/</guid>
      <description>1001.网格照明 hard 2022.02.08 数据规模太大了, 原本想着硬模拟的后来还是放弃了
打算用map去存储行列和两个对角的情况, 但是又不知道怎么去表示同一条对角
官方题解:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  func gridIllumination(n int, lamps, queries [][]int) []int { type pair struct{ x, y int } points := map[pair]bool{} row := map[int]int{} col := map[int]int{} diagonal := map[int]int{} antiDiagonal := map[int]int{} for _, lamp := range lamps { r, c := lamp[0], lamp[1] p := pair{r, c} if points[p] { continue } points[p] = true row[r]++ col[c]++ //用这个来表示哪条对角, 妙啊  diagonal[r-c]++ antiDiagonal[r+c]++ } ans := make([]int, len(queries)) for i, query := range queries { r, c := query[0], query[1] if row[r] &amp;gt; 0 || col[c] &amp;gt; 0 || diagonal[r-c] &amp;gt; 0 || antiDiagonal[r+c] &amp;gt; 0 { ans[i] = 1 } for x := r - 1; x &amp;lt;= r+1; x++ { for y := c - 1; y &amp;lt;= c+1; y++ { if x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= n || !</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220109/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:58 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220109/</guid>
      <description>田忌赛马,打不过就送人头 代码逻辑
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  n := len(nums1) sort.Ints(nums1) //田忌的马 sort.Ints(nums2) //齐王的马  for i := n-1; i &amp;gt;= 0; i-- { if nums1[i] &amp;gt; nums2[i] { //比得过跟他比  } else { //比不过,换的垫底的来送人头  } } int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220108/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:54 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220108/</guid>
      <description>滑动窗口问题 1 2 3 4 5 6 7 8 9 10  int left = 0, right = 0 for right &amp;lt; len(s) { //增大窗口  window.add(s[right]) right++ for window needs shrink{ window.remove(s[left]) left++ } }   O(N)
框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  //滑动窗口算法框架 func slidingWindow(s, t string) { need := make(map[string]int) window := make(map[string]int) for _,c := range t{ need[string(c)]++ } left,right,valid := 0,0,0 for right &amp;lt; len(s) { //c是将移入窗口的字符  c := s[right] //右移窗口  right++ //对窗口内数据的一系列更新  .</description>
    </item>
    
    <item>
      <title>2022-01-09</title>
      <link>https://zyooo.github.io/leetcodedairy/20220107/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220107/</guid>
      <description>二分搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  //搜素左侧边界 func left_bound(nums []int, target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩右侧边界  right = mid }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 2 //搜索右侧边界 func right_bound(nums int[], target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩左侧边界  left = mid + 1 }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 4   技巧: 从题目中抽象出一个自变量x , 一个关于x的函数f(x), 以及一个目标值 target , 同时还要满足以下条件 : 1.</description>
    </item>
    
    <item>
      <title>2022-01-06</title>
      <link>https://zyooo.github.io/leetcodedairy/20220106/</link>
      <pubDate>Thu, 06 Jan 2022 11:18:06 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220106/</guid>
      <description>15.三数之和 穷举,确定了第一个数字之后, 剩下两个数字就是 target = target - nums[i] 的twoSum问题
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  func twoSumTarget2(nums []int, start, target int) [][]int { var ans [][]int //sort.Ints(nums)  lo, hi := start, len(nums)-1 for lo &amp;lt; hi { sum := nums[lo] + nums[hi] left, right := nums[lo], nums[hi] if sum &amp;lt; target { for lo &amp;lt; hi &amp;amp;&amp;amp; nums[lo] == left { //跳过重复项,保证答案唯一  lo++ } } else if sum &amp;gt; target { for lo &amp;lt; hi &amp;amp;&amp;amp; nums[hi] == right { hi-- } } else { ans = append(ans, []int{nums[lo], nums[hi]}) for lo &amp;lt; hi &amp;amp;&amp;amp; nums[lo] == left { lo++ } for lo &amp;lt; hi &amp;amp;&amp;amp; nums[hi] == right { hi-- } } } return ans } func threeSumTarget(nums []int, target int) [][]int { sort.</description>
    </item>
    
    <item>
      <title>2022-01-05</title>
      <link>https://zyooo.github.io/leetcodedairy/20220105/</link>
      <pubDate>Wed, 05 Jan 2022 07:49:09 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220105/</guid>
      <description>1576.替换所有的问号 1 2 3 4 5 6 7 8 9 10 11 12 13 14  func modifyString(s string) string { data := []byte(s) for i := 0; i &amp;lt; len(data); i++ { if data[i] == &amp;#39;?&amp;#39; { for b := byte(&amp;#39;a&amp;#39;); b &amp;lt;= &amp;#39;c&amp;#39;; b++ { if !(i &amp;gt; 0 &amp;amp;&amp;amp; data[i-1] == b || i &amp;lt; len(data)-1 &amp;amp;&amp;amp; data[i+1] == b) { data[i] = b break } } } } return string(data[:]) }   一个点在于, 实际上只需要遍历三个字母,就可以找到适合的答案, 还有就是里面那个 if 语句很好的解决了i=0 和</description>
    </item>
    
    <item>
      <title>2022-01-04</title>
      <link>https://zyooo.github.io/leetcodedairy/20220104/</link>
      <pubDate>Tue, 04 Jan 2022 07:46:10 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220104/</guid>
      <description>19.删除链表的倒数第N个节点 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := new(ListNode) dummy.Next = head x := findFromEnd(dummy,n+1) //找到倒数第n+1个然后将倒数第n个删除  x.Next = x.Next.Next return dummy.Next } func findFromEnd(head *ListNode,k int) *ListNode{ p1,p2 := head,head for i := 0; i &amp;lt; k; i++{ p1 = p1.</description>
    </item>
    
    <item>
      <title>2022-01-03</title>
      <link>https://zyooo.github.io/leetcodedairy/20220103/</link>
      <pubDate>Mon, 03 Jan 2022 18:29:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220103/</guid>
      <description>1185.一周中的第几天 难度简单92
给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
输入为三个整数：day、month 和 year，分别表示日、月、年。
您返回的结果必须是这几个值中的一个 {&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;}。
用了一个公式： W = (D + 2 * M + 3 * (M + 1) \ 5 + Y + Y \ 4 - Y \ 100 + Y \ 400+1) Mod 7
但是一月和二月要用13,14表示。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public String dayOfTheWeek(int day, int month, int year) { String[] days = {&amp;#34;Sunday&amp;#34;,&amp;#34;Monday&amp;#34;,&amp;#34;Tuesday&amp;#34;,&amp;#34;Wednesday&amp;#34;,&amp;#34;Thursday&amp;#34;,&amp;#34;Friday&amp;#34;,&amp;#34;Saturday&amp;#34;}; if(month == 1){ month = 13; year--; }else if(month == 2){ month = 14; year --; } //W = (D + 2 * M + 3 * (M + 1) \ 5 + Y + Y \ 4 - Y \ 100 + Y \ 400+1) Mod 7  return days[(day + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400 + 1) % 7]; } }   23.</description>
    </item>
    
    <item>
      <title>2021-11-17</title>
      <link>https://zyooo.github.io/leetcodedairy/20211117/</link>
      <pubDate>Wed, 17 Nov 2021 12:15:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211117/</guid>
      <description>318.最大单词长度乘积 1 2 3 4 5  给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-of-word-lengths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处.   本来以为简简单单，结果发现看漏了题目中不含有公共字母的两个单词。然后感觉难度暴增，最后也是成功写出了屎一般的代码，11%+6%。看了题解之后学到了新的东西，思路其实差不多，最优的时间复杂度也是要O(n²)，但是在比较是否出现公共字母的时候，不想用int[26]去表示一个字符串出现过的字母，那样子空间和时间都花费很多，最后看了题解发现可以用掩码去解决，就是用一个int的低26位表示，效果和数组一样，而且比较只需要&amp;amp;运算就能算出，快太多了。
官方题解是将mask（掩码）作为map的key，length作为map的val，然后再去双重遍历keySet得出最大的答案。按照这个思路做了之后，还是不够快，最后去看高速度的题解，才发现有更快的方法！真是厉害，直接不用map，用于words长度相等的一个int[]去存放掩码，然后通过对应的数组下标可以直接得到words[i].length()空间上更加节省了，同时因为是有顺序去二重遍历的，所以一重循环i&amp;lt;words.length-1，而二重循环的ｊ的开始是ｉ＋１，因为在在前面ｉ的遍历中已经和当前ｊ匹配过了，所以无需再匹配了。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Solution { public int maxProduct(String[] words) { int ans = 0; //words中每个string对应的掩码  int[] masks = new int[words.length]; for(int i = 0; i &amp;lt; words.length; i++){ for(char c : words[i].</description>
    </item>
    
    <item>
      <title>Day6-2021-11-15</title>
      <link>https://zyooo.github.io/leetcodedairy/20211115/</link>
      <pubDate>Mon, 15 Nov 2021 10:58:22 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211115/</guid>
      <description>319.灯泡开关 @脑筋急转弯
1 2 3 4 5 6 7 8 9  初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。 找出并返回 n 轮后有多少个亮着的灯泡。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bulb-switcher 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。   最开始模拟了整个过程,结果测试例子给个99999999,直接超出内存限制,感觉事情并不简单.
题解:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution { public int bulbSwitch(int n) { return (int) Math.sqrt(n); } } /* 影响第x位灯泡的因素是他的约数 例如6, 约数为1,2,3,6 第一轮即点亮所有,2是关闭,3是点亮,最后6会关闭,所以有偶数个约数的位的灯泡最后都是关闭 所以只有奇数个约数的位最后才会被点亮,即为完全平方数 例如4,约数为1,2,4 n个数中,完全平方数的数量刚好为sqrt(n)向下取整 例如n=9,其中1,4,9为平方数,数量为sqrt(9) = 3 1&amp;lt;= x² &amp;lt;= n 1&amp;lt;= x &amp;lt;= sqrt(n) */   </description>
    </item>
    
    <item>
      <title>2021-11-05</title>
      <link>https://zyooo.github.io/leetcodedairy/20211105/</link>
      <pubDate>Fri, 05 Nov 2021 12:21:38 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211105/</guid>
      <description>重塑矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reshape-the-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。   原本想的就是先判断面积是否相等,然后将速度按照rc去放入,但是赶着吃饭没想明白用取余的具体操作,就直接暴力了.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { if(r*c !</description>
    </item>
    
    <item>
      <title>2021-11-04</title>
      <link>https://zyooo.github.io/leetcodedairy/20211104/</link>
      <pubDate>Thu, 04 Nov 2021 20:40:11 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211104/</guid>
      <description>两个数组的交集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。   我的思路是先把一个数组存入hashmap中,用值来当key,value为这个数组中这个数字的出现次数,然后遍历第二个数组,当map中有这个值存在而且value大于0,就将这个值加入到list中,最后再将list转化为int[],但是不能直接转换成int[],只能直接转换成Integer[],所以就采用了遍历赋值的方法.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution { public int[] intersect(int[] nums1, int[] nums2) { Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int x : nums1) { if(map.</description>
    </item>
    
    <item>
      <title>2021-11-03</title>
      <link>https://zyooo.github.io/leetcodedairy/20211103/</link>
      <pubDate>Wed, 03 Nov 2021 19:59:17 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211103/</guid>
      <description>合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
1 2 3 4 5 6 7 8 9 10  示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>2021-10-31</title>
      <link>https://zyooo.github.io/leetcodedairy/20211031/</link>
      <pubDate>Sun, 31 Oct 2021 21:22:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211031/</guid>
      <description>最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
1 2 3 4  示例: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。   用贪心算法去解决此问题,遍历数组,得到当前的值,如果lastCount小于零的话就抛弃,当前和就等于当前值,如果lastCount大于等于0的话就和当前值相加作为当前和,lastCount等于当前和,当前和和最大和比较,得出最大和,遍历完一边之后返回最大和.
时间复杂度:O(n) 空间复杂度: O(1)
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class Solution { public int maxSubArray(int[] nums) { int index = 0; int lastCount = 0; int maxCount = 0; for(int currentNum : nums){ int currentCount; if(index == 0){ index++; currentCount = currentNum; lastCount = currentCount; maxCount = currentCount; }else{ if(lastCount &amp;lt; 0){ currentCount = currentNum; maxCount = (maxCount &amp;gt; currentCount) ?</description>
    </item>
    
    <item>
      <title>2021.10.08</title>
      <link>https://zyooo.github.io/leetcodedairy/20211008/</link>
      <pubDate>Sat, 09 Oct 2021 11:35:50 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211008/</guid>
      <description>1.旅行终点站 简单 2021.10.08 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
解题的思路就是遍历一遍paths，取cityB，第二重遍历取cityA，当第二重遍历的cityA等于第一重遍历的cityB时说明这条路线是有出路的，反之当第二重遍历结束后依然没有对应的cityA，说明此时第一重遍历的cityB即为终点。
但是实现方式过于单一，没有去向其他更快捷的方式，导致速度太慢，参考官方题解当中，利用哈希表HashSet去储存一组需要遍历的量，提高速度。
1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Solution { public String destCity(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { for(int i=0; i&amp;lt;paths.size(); i++){ for(int j=0; j&amp;lt;paths.size(); j++){ if(i!=j &amp;amp;&amp;amp; paths.get(i).get(1).equals(paths.get(j).get(0))){ break; }else if(j==paths.size()-1){ return paths.get(i).get(1); } } } return &amp;#34;&amp;#34;; } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //官方题解 class Solution { public String destCity(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { Set&amp;lt;String&amp;gt; citiesA = new HashSet&amp;lt;String&amp;gt;(); for (List&amp;lt;String&amp;gt; path : paths) { citiesA.</description>
    </item>
    
  </channel>
</rss>