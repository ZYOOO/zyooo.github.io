<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LeetCodeDairies on Ray</title>
    <link>https://zyooo.github.io/leetcodedairy/</link>
    <description>Recent content in LeetCodeDairies on Ray</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Feb 2022 20:07:20 +0800</lastBuildDate><atom:link href="https://zyooo.github.io/leetcodedairy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>20220208</title>
      <link>https://zyooo.github.io/leetcodedairy/20220208/</link>
      <pubDate>Sun, 20 Feb 2022 20:07:20 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220208/</guid>
      <description>1001.网格照明 hard 2022.02.08 数据规模太大了, 原本想着硬模拟的后来还是放弃了
打算用map去存储行列和两个对角的情况, 但是又不知道怎么去表示同一条对角
官方题解:
func gridIllumination(n int, lamps, queries [][]int) []int { type pair struct{ x, y int } points := map[pair]bool{} row := map[int]int{} col := map[int]int{} diagonal := map[int]int{} antiDiagonal := map[int]int{} for _, lamp := range lamps { r, c := lamp[0], lamp[1] p := pair{r, c} if points[p] { continue } points[p] = true row[r]++ col[c]++ //用这个来表示哪条对角, 妙啊  diagonal[r-c]++ antiDiagonal[r+c]++ } ans := make([]int, len(queries)) for i, query := range queries { r, c := query[0], query[1] if row[r] &amp;gt; 0 || col[c] &amp;gt; 0 || diagonal[r-c] &amp;gt; 0 || antiDiagonal[r+c] &amp;gt; 0 { ans[i] = 1 } for x := r - 1; x &amp;lt;= r+1; x++ { for y := c - 1; y &amp;lt;= c+1; y++ { if x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= n || y &amp;gt;= n || !</description>
    </item>
    
    <item>
      <title>Day14</title>
      <link>https://zyooo.github.io/leetcodedairy/20220109/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:58 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220109/</guid>
      <description>田忌赛马,打不过就送人头 代码逻辑
n := len(nums1) sort.Ints(nums1) //田忌的马 sort.Ints(nums2) //齐王的马  for i := n-1; i &amp;gt;= 0; i-- { if nums1[i] &amp;gt; nums2[i] { //比得过跟他比  } else { //比不过,换的垫底的来送人头  } } int[] advantageCount(int[] nums1, int[] nums2) { int n = nums1.length; // 给 nums2 降序排序  PriorityQueue&amp;lt;int[]&amp;gt; maxpq = new PriorityQueue&amp;lt;&amp;gt;( (int[] pair1, int[] pair2) -&amp;gt; { return pair2[1] - pair1[1]; //比较方式  } ); for (int i = 0; i &amp;lt; n; i++) { maxpq.</description>
    </item>
    
    <item>
      <title>Day13</title>
      <link>https://zyooo.github.io/leetcodedairy/20220108/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:54 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220108/</guid>
      <description>滑动窗口问题 int left = 0, right = 0 for right &amp;lt; len(s) { //增大窗口  window.add(s[right]) right++ for window needs shrink{ window.remove(s[left]) left++ } } O(N)
框架 //滑动窗口算法框架 func slidingWindow(s, t string) { need := make(map[string]int) window := make(map[string]int) for _,c := range t{ need[string(c)]++ } left,right,valid := 0,0,0 for right &amp;lt; len(s) { //c是将移入窗口的字符  c := s[right] //右移窗口  right++ //对窗口内数据的一系列更新  ... //debug输出的位置  fmt.Printf(&amp;#34;window: [%d,%d)\n&amp;#34;,left,right) //判断左侧窗口是否要收缩  for window needs shrink{ //d 是将移出窗口的字符  d := s[left] //左移窗口  left++ //进行窗口内数据的一系列更新  .</description>
    </item>
    
    <item>
      <title>Day12</title>
      <link>https://zyooo.github.io/leetcodedairy/20220107/</link>
      <pubDate>Sun, 09 Jan 2022 20:34:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220107/</guid>
      <description>二分搜索 //搜素左侧边界 func left_bound(nums []int, target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩右侧边界  right = mid }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 2 //搜索右侧边界 func right_bound(nums int[], target int){ if len(nums) == 0 { return -1 } left, right := 0,len(nums) for left &amp;lt; right{ mid := left + (right - left) / 2 if nums[mid] == target{ //找到target时,收缩左侧边界  left = mid + 1 }else if nums[mid] &amp;lt; target{ left = mid + 1 }else if nums[mid] &amp;gt; target{ right = mid } } return left } // nums = [1,2,3,3,3,5,7,] target = 3 return 4 技巧: 从题目中抽象出一个自变量x , 一个关于x的函数f(x), 以及一个目标值 target , 同时还要满足以下条件 : 1.</description>
    </item>
    
    <item>
      <title>Day11</title>
      <link>https://zyooo.github.io/leetcodedairy/20220106/</link>
      <pubDate>Thu, 06 Jan 2022 11:18:06 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220106/</guid>
      <description>15.三数之和 穷举,确定了第一个数字之后, 剩下两个数字就是 target = target - nums[i] 的twoSum问题
func twoSumTarget2(nums []int, start, target int) [][]int { var ans [][]int //sort.Ints(nums)  lo, hi := start, len(nums)-1 for lo &amp;lt; hi { sum := nums[lo] + nums[hi] left, right := nums[lo], nums[hi] if sum &amp;lt; target { for lo &amp;lt; hi &amp;amp;&amp;amp; nums[lo] == left { //跳过重复项,保证答案唯一  lo++ } } else if sum &amp;gt; target { for lo &amp;lt; hi &amp;amp;&amp;amp; nums[hi] == right { hi-- } } else { ans = append(ans, []int{nums[lo], nums[hi]}) for lo &amp;lt; hi &amp;amp;&amp;amp; nums[lo] == left { lo++ } for lo &amp;lt; hi &amp;amp;&amp;amp; nums[hi] == right { hi-- } } } return ans } func threeSumTarget(nums []int, target int) [][]int { sort.</description>
    </item>
    
    <item>
      <title>Day10</title>
      <link>https://zyooo.github.io/leetcodedairy/20220105/</link>
      <pubDate>Wed, 05 Jan 2022 07:49:09 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220105/</guid>
      <description>1576.替换所有的问号 func modifyString(s string) string { data := []byte(s) for i := 0; i &amp;lt; len(data); i++ { if data[i] == &amp;#39;?&amp;#39; { for b := byte(&amp;#39;a&amp;#39;); b &amp;lt;= &amp;#39;c&amp;#39;; b++ { if !(i &amp;gt; 0 &amp;amp;&amp;amp; data[i-1] == b || i &amp;lt; len(data)-1 &amp;amp;&amp;amp; data[i+1] == b) { data[i] = b break } } } } return string(data[:]) } 一个点在于, 实际上只需要遍历三个字母,就可以找到适合的答案, 还有就是里面那个 if 语句很好的解决了i=0 和
i = length-1的问题.
[]byte和string之间的转化方式 res := []byte( s ) string(res)</description>
    </item>
    
    <item>
      <title>Day9</title>
      <link>https://zyooo.github.io/leetcodedairy/20220104/</link>
      <pubDate>Tue, 04 Jan 2022 07:46:10 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220104/</guid>
      <description>19.删除链表的倒数第N个节点 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { dummy := new(ListNode) dummy.Next = head x := findFromEnd(dummy,n+1) //找到倒数第n+1个然后将倒数第n个删除  x.Next = x.Next.Next return dummy.Next } func findFromEnd(head *ListNode,k int) *ListNode{ p1,p2 := head,head for i := 0; i &amp;lt; k; i++{ p1 = p1.Next } for p1 != nil{ p1 = p1.</description>
    </item>
    
    <item>
      <title>Day8</title>
      <link>https://zyooo.github.io/leetcodedairy/20220103/</link>
      <pubDate>Mon, 03 Jan 2022 18:29:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20220103/</guid>
      <description>1185.一周中的第几天 难度简单92
给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
输入为三个整数：day、month 和 year，分别表示日、月、年。
您返回的结果必须是这几个值中的一个 {&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;}。
用了一个公式： W = (D + 2 * M + 3 * (M + 1) \ 5 + Y + Y \ 4 - Y \ 100 + Y \ 400+1) Mod 7
但是一月和二月要用13,14表示。
class Solution { public String dayOfTheWeek(int day, int month, int year) { String[] days = {&amp;#34;Sunday&amp;#34;,&amp;#34;Monday&amp;#34;,&amp;#34;Tuesday&amp;#34;,&amp;#34;Wednesday&amp;#34;,&amp;#34;Thursday&amp;#34;,&amp;#34;Friday&amp;#34;,&amp;#34;Saturday&amp;#34;}; if(month == 1){ month = 13; year--; }else if(month == 2){ month = 14; year --; } //W = (D + 2 * M + 3 * (M + 1) \ 5 + Y + Y \ 4 - Y \ 100 + Y \ 400+1) Mod 7  return days[(day + 2 * month + 3 * (month + 1) / 5 + year + year / 4 - year / 100 + year / 400 + 1) % 7]; } } 23.</description>
    </item>
    
    <item>
      <title>Day7-2021-11-17</title>
      <link>https://zyooo.github.io/leetcodedairy/20211117/</link>
      <pubDate>Wed, 17 Nov 2021 12:15:12 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211117/</guid>
      <description>318.最大单词长度乘积 给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-product-of-word-lengths 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处. 本来以为简简单单，结果发现看漏了题目中不含有公共字母的两个单词。然后感觉难度暴增，最后也是成功写出了屎一般的代码，11%+6%。看了题解之后学到了新的东西，思路其实差不多，最优的时间复杂度也是要O(n²)，但是在比较是否出现公共字母的时候，不想用int[26]去表示一个字符串出现过的字母，那样子空间和时间都花费很多，最后看了题解发现可以用掩码去解决，就是用一个int的低26位表示，效果和数组一样，而且比较只需要&amp;amp;运算就能算出，快太多了。
官方题解是将mask（掩码）作为map的key，length作为map的val，然后再去双重遍历keySet得出最大的答案。按照这个思路做了之后，还是不够快，最后去看高速度的题解，才发现有更快的方法！真是厉害，直接不用map，用于words长度相等的一个int[]去存放掩码，然后通过对应的数组下标可以直接得到words[i].length()空间上更加节省了，同时因为是有顺序去二重遍历的，所以一重循环i&amp;lt;words.length-1，而二重循环的ｊ的开始是ｉ＋１，因为在在前面ｉ的遍历中已经和当前ｊ匹配过了，所以无需再匹配了。
class Solution { public int maxProduct(String[] words) { int ans = 0; //words中每个string对应的掩码  int[] masks = new int[words.length]; for(int i = 0; i &amp;lt; words.length; i++){ for(char c : words[i].toCharArray()) masks[i] |= 1&amp;lt;&amp;lt;(c-&amp;#39;a&amp;#39;); } //二重遍历  for(int i = 0; i &amp;lt; words.length-1; i++){ for(int j = i+1; j &amp;lt; words.length; j++){ //字符串无公共字母  if((masks[i] &amp;amp; masks[j]) == 0) ans = Math.</description>
    </item>
    
    <item>
      <title>Day6-2021-11-15</title>
      <link>https://zyooo.github.io/leetcodedairy/20211115/</link>
      <pubDate>Mon, 15 Nov 2021 10:58:22 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211115/</guid>
      <description>319.灯泡开关 @脑筋急转弯
初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。 第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。 找出并返回 n 轮后有多少个亮着的灯泡。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/bulb-switcher 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 最开始模拟了整个过程,结果测试例子给个99999999,直接超出内存限制,感觉事情并不简单.
题解:
class Solution { public int bulbSwitch(int n) { return (int) Math.sqrt(n); } } /* 影响第x位灯泡的因素是他的约数 例如6, 约数为1,2,3,6 第一轮即点亮所有,2是关闭,3是点亮,最后6会关闭,所以有偶数个约数的位的灯泡最后都是关闭 所以只有奇数个约数的位最后才会被点亮,即为完全平方数 例如4,约数为1,2,4 n个数中,完全平方数的数量刚好为sqrt(n)向下取整 例如n=9,其中1,4,9为平方数,数量为sqrt(9) = 3 1&amp;lt;= x² &amp;lt;= n 1&amp;lt;= x &amp;lt;= sqrt(n) */ </description>
    </item>
    
    <item>
      <title>Day5-2021-11-05</title>
      <link>https://zyooo.github.io/leetcodedairy/20211105/</link>
      <pubDate>Fri, 05 Nov 2021 12:21:38 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211105/</guid>
      <description>重塑矩阵 在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 示例 1： 输入：mat = [[1,2],[3,4]], r = 1, c = 4 输出：[[1,2,3,4]] 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reshape-the-matrix 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 原本想的就是先判断面积是否相等,然后将速度按照rc去放入,但是赶着吃饭没想明白用取余的具体操作,就直接暴力了.
class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { if(r*c != mat.length*mat[0].length){ return mat; } int[] arr = new int[r*c]; int index = 0; for(int i = 0; i &amp;lt; mat.</description>
    </item>
    
    <item>
      <title>Day4-2021-11-04</title>
      <link>https://zyooo.github.io/leetcodedairy/20211104/</link>
      <pubDate>Thu, 04 Nov 2021 20:40:11 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211104/</guid>
      <description>两个数组的交集 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2,2] 示例 2: 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 我的思路是先把一个数组存入hashmap中,用值来当key,value为这个数组中这个数字的出现次数,然后遍历第二个数组,当map中有这个值存在而且value大于0,就将这个值加入到list中,最后再将list转化为int[],但是不能直接转换成int[],只能直接转换成Integer[],所以就采用了遍历赋值的方法.
class Solution { public int[] intersect(int[] nums1, int[] nums2) { Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); for (int x : nums1) { if(map.containsKey(x)){ map.put(x,map.get(x)+1); }else{ map.put(x,1); } } for(int x : nums2){ if(map.get(x) != null &amp;amp;&amp;amp; map.get(x) &amp;gt; 0){ list.</description>
    </item>
    
    <item>
      <title>Day3-2021-11-03</title>
      <link>https://zyooo.github.io/leetcodedairy/20211103/</link>
      <pubDate>Wed, 03 Nov 2021 19:59:17 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211103/</guid>
      <description>合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-sorted-array 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 使用双指针比较两数组尾,即排序后的最大数值,倒序放入nums1中,如果两个数组中的一个已经遍历完,则剩余的都为另一数组剩余的.
class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { //从尾部开始比谁大再放入tail指向的nums1中值  int p1 = m-1; int p2 = n-1; int tail = m+n-1; while(p2 &amp;gt;= 0 || p1 &amp;gt;= 0){ //m个已经全部放完,剩下的全部放nums2  if(p1 == -1){ nums1[tail--] = nums2[p2--]; }else if(p2 == -1){ nums1[tail--] = nums1[p1--]; }else if(nums2[p2] &amp;gt;= nums1[p1]){ nums1[tail--] = nums2[p2--]; }else{ nums1[tail--] = nums1[p1--]; } } } } 两数之和 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 来源：力扣（LeetCode） 链接：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>Day2-2021-10-31</title>
      <link>https://zyooo.github.io/leetcodedairy/20211031/</link>
      <pubDate>Sun, 31 Oct 2021 21:22:51 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211031/</guid>
      <description>最大子序和 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例: 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 用贪心算法去解决此问题,遍历数组,得到当前的值,如果lastCount小于零的话就抛弃,当前和就等于当前值,如果lastCount大于等于0的话就和当前值相加作为当前和,lastCount等于当前和,当前和和最大和比较,得出最大和,遍历完一边之后返回最大和.
时间复杂度:O(n) 空间复杂度: O(1)
class Solution { public int maxSubArray(int[] nums) { int index = 0; int lastCount = 0; int maxCount = 0; for(int currentNum : nums){ int currentCount; if(index == 0){ index++; currentCount = currentNum; lastCount = currentCount; maxCount = currentCount; }else{ if(lastCount &amp;lt; 0){ currentCount = currentNum; maxCount = (maxCount &amp;gt; currentCount) ? maxCount : currentCount; lastCount = currentCount; }else{ currentCount = currentNum + lastCount; maxCount = (maxCount &amp;gt; currentCount) ?</description>
    </item>
    
    <item>
      <title>2021.10.08</title>
      <link>https://zyooo.github.io/leetcodedairy/20211008/</link>
      <pubDate>Sat, 09 Oct 2021 11:35:50 +0800</pubDate>
      
      <guid>https://zyooo.github.io/leetcodedairy/20211008/</guid>
      <description>1.旅行终点站 简单 2021.10.08 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
解题的思路就是遍历一遍paths，取cityB，第二重遍历取cityA，当第二重遍历的cityA等于第一重遍历的cityB时说明这条路线是有出路的，反之当第二重遍历结束后依然没有对应的cityA，说明此时第一重遍历的cityB即为终点。
但是实现方式过于单一，没有去向其他更快捷的方式，导致速度太慢，参考官方题解当中，利用哈希表HashSet去储存一组需要遍历的量，提高速度。
class Solution { public String destCity(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { for(int i=0; i&amp;lt;paths.size(); i++){ for(int j=0; j&amp;lt;paths.size(); j++){ if(i!=j &amp;amp;&amp;amp; paths.get(i).get(1).equals(paths.get(j).get(0))){ break; }else if(j==paths.size()-1){ return paths.get(i).get(1); } } } return &amp;#34;&amp;#34;; } } //官方题解 class Solution { public String destCity(List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; paths) { Set&amp;lt;String&amp;gt; citiesA = new HashSet&amp;lt;String&amp;gt;(); for (List&amp;lt;String&amp;gt; path : paths) { citiesA.add(path.get(0)); } for (List&amp;lt;String&amp;gt; path : paths) { if (!</description>
    </item>
    
  </channel>
</rss>
