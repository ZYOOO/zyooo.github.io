<!doctype html>
<html lang="en-us">
  <head>
    <title>BigTalkDesignPattenNote // Ray</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.70.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Ray" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://zyooo.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="BigTalkDesignPattenNote"/>
<meta name="twitter:description" content="大话设计模式读书笔记 1.简单工厂模式 用一个单独的类来做创照实例的过程，这就是工厂
public class OperationFactory{ public static Operation createOperate(string operate){ Operation oper = null; switch(operate){ case &quot;&#43;&quot;: oper = new OperationAdd(); break; case &quot;-&quot;: oper = new OperationSub(); break; case &quot;*&quot;: oper = new OperationMul(); break; case &quot;/&quot;: oper = new OperationMul(); break; } return oper; } } Operation oper; oper = OperationFactory.createOperate(&quot;&#43;&quot;); oper.NumberA = 1; oper.NumberB = 2; double result = oper.GetResult(); *UML类图 UML类图图示样例
类图 类图分为三层
第一层显示类的名称，如果是抽象类，则就用斜体显示。
第二层是类的特性，通常就是字段和属性。"/>

    <meta property="og:title" content="BigTalkDesignPattenNote" />
<meta property="og:description" content="大话设计模式读书笔记 1.简单工厂模式 用一个单独的类来做创照实例的过程，这就是工厂
public class OperationFactory{ public static Operation createOperate(string operate){ Operation oper = null; switch(operate){ case &quot;&#43;&quot;: oper = new OperationAdd(); break; case &quot;-&quot;: oper = new OperationSub(); break; case &quot;*&quot;: oper = new OperationMul(); break; case &quot;/&quot;: oper = new OperationMul(); break; } return oper; } } Operation oper; oper = OperationFactory.createOperate(&quot;&#43;&quot;); oper.NumberA = 1; oper.NumberB = 2; double result = oper.GetResult(); *UML类图 UML类图图示样例
类图 类图分为三层
第一层显示类的名称，如果是抽象类，则就用斜体显示。
第二层是类的特性，通常就是字段和属性。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zyooo.github.io/note/bigtalkdesignpattennote/" />
<meta property="article:published_time" content="2021-10-08T14:23:01+08:00" />
<meta property="article:modified_time" content="2021-10-08T14:23:01+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://zyooo.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Ray" /></a>
      <h1>Ray</h1>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/note/">NOTE</a>
             - 
          
          <a class="app-header-menu-item" href="/leetcodedairy/">LeetCodeDairy</a>
             - 
          
          <a class="app-header-menu-item" href="/bugs/">Bugs</a>
             - 
          
          <a class="app-header-menu-item" href="/javadairy/">JavaDairy</a>
      </nav>
      <p>What everyonne you can do,just do it.</p>
      <div class="app-header-social">
        
          <a href="https://github.com/zyooo" target="_blank" rel="noreferrer noopener">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>My Github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg>
          </a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">BigTalkDesignPattenNote</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Oct 8, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="大话设计模式读书笔记">大话设计模式读书笔记</h1>
<h2 id="1简单工厂模式">1.简单工厂模式</h2>
<p>用一个单独的类来做创照实例的过程，这就是工厂</p>
<p><img src="https://i.loli.net/2021/10/08/WTt8c4aLhlpxn3u.png" alt="image-20211008170555461"></p>
<pre><code>public class OperationFactory{
	public static Operation createOperate(string operate){
		Operation oper = null;
		switch(operate){
			case &quot;+&quot;:
				oper = new OperationAdd();
				break;
			case &quot;-&quot;:
				oper = new OperationSub();
				break;
			case &quot;*&quot;:
				oper = new OperationMul();
				break;
			case &quot;/&quot;:
				oper = new OperationMul();
				break;
		}
		return oper;
	}
}
</code></pre><pre><code>Operation oper;
oper = OperationFactory.createOperate(&quot;+&quot;);
oper.NumberA = 1;
oper.NumberB = 2;
double result = oper.GetResult();
</code></pre><h3 id="uml类图">*UML类图</h3>
<p><strong>UML类图图示样例</strong></p>
<p><img src="https://i.loli.net/2021/10/08/geMjNRQAEsr1Hbo.png" alt="image-20211008170613771"></p>
<h4 id="类图">类图</h4>
<p>类图分为三层</p>
<p>第一层显示类的名称，如果是抽象类，则就用斜体显示。</p>
<p>第二层是类的特性，通常就是字段和属性。</p>
<p>第三层是类的操作，通常是方法或行为。</p>
<p>&ldquo;+&quot;表示public，&quot;-&ldquo;表示private ， &ldquo;#&ldquo;表示protected。</p>
<p><img src="https://i.loli.net/2021/10/08/2AOx6mIhFYZ5unf.png" alt="image-20211008170943057"></p>
<h4 id="接口图">接口图</h4>
<p>顶端有《interface》</p>
<p>第一行是接口名称</p>
<p>第二行是接口方法</p>
<p><img src="https://i.loli.net/2021/10/08/swc47SWfu9odF36.png" alt="image-20211008171626373"></p>
<h4 id="继承">继承</h4>
<p>空心三角形+实线来表示</p>
<p><img src="https://i.loli.net/2021/10/08/oYsBUELmpFWDraI.png" alt="image-20211008171717526"></p>
<h4 id="接口">接口</h4>
<p>空心三角形+虚线表示</p>
<p><img src="https://i.loli.net/2021/10/08/hpISznZJRecABNt.png" alt="image-20211008171946522"></p>
<h4 id="关联">关联</h4>
<p>放一个类知道另一个类时，实线箭头来表示</p>
<pre><code>class Penguin : Bird{
	private Climate climate;
}
</code></pre><p><img src="https://i.loli.net/2021/10/08/TBVYyQGwExFLD9W.png" alt="image-20211008172039252"></p>
<h4 id="聚合">聚合</h4>
<p><strong>&ldquo;聚合表示一种弱的 &lsquo;拥有&rsquo; 关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分&rdquo;</strong></p>
<p>用空心的菱形+实线箭头来表示</p>
<p><img src="https://i.loli.net/2021/10/08/fc1w2oaymVUHriM.png" alt="image-20211008172407721"></p>
<h4 id="合成">合成</h4>
<p><strong>“合成（Composition，也有翻译成‘组合’的）是一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样”</strong></p>
<p>用实心的菱形+实线箭头表示</p>
<p><img src="https://i.loli.net/2021/10/08/rGONmtvPz4EVi9j.png" alt="image-20211008172738136"></p>
<h4 id="依赖关系">依赖关系</h4>
<p>虚线箭头表示</p>
<p><img src="https://i.loli.net/2021/10/08/1WVvkzxaEYTAtUc.png" alt="image-20211008172823700"></p>
<p>2021.10.08</p>
<h2 id="2策略模式">2.策略模式</h2>
<p><strong>策略模式</strong>（Strategy）：它定义了 <strong>算法家族</strong> ，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。</p>
<p><img src="https://i.loli.net/2021/10/10/7kHJar8YvOnRmfD.jpg" alt="4935907e54f73452142b0f8cd3519a6"></p>
<p>承担Strategy角色的一个类上定义所有支持的算法的公共接口，它的子类去实现各种不同的策略（算法）。</p>
<p>然后创建一个Context类，里面创建维护一个Strategy对象，（初始化需要做的判断可以放在这里，简单工厂和策略模式的结合，减轻客户端的压力）在初始化Context类的时候需要传入Strategy参数，这里传入的应该是Strategy的子类也就是各种实际的策略。在ContextInterface()中用strategy去调用Strategy中的那个公共接口，最后得到响应策略（算法）的结果，返回给客户端。</p>
<p>书本案例&mdash;市场促销</p>
<p><img src="https://i.loli.net/2021/10/10/cOLYq5BnjtXaA91.jpg" alt="a11de6923fd44929fef848cb1001cc9"></p>
<pre><code>class CashContext{
	CashSuper cs = null;
	public CashContext (string type){
		case &quot;正常收费&quot;:
			CashNormal cs0 = new CashNormal();
			cs = cs0;
			break;
		case &quot;满300返100&quot;:
			CashNormal cr1 = new CashReturn(&quot;300&quot;,&quot;100&quot;);
			cs = cr1;
			break;
		case &quot;打8折&quot;:
			CashNormal cr2 = new CashNormal(&quot;0.8&quot;);
			cs = cr2;
			break;
	}
	public double GetResult(double money){
		return cs.acceptCash(money);
	}
}
</code></pre><pre><code>//客户端窗体程序(主要部分)
doule total = 0.0d;
private void btnOk_Click(Object sender,EvenArgs e){
	CashContext csuper = new CashContext(cbxType.SelectedItem.ToString());
	double totalPrices = 0d;
	totalPrices = csuper.getResult(Conver.ToDouble(txtPrice.Text) * Convert.ToDouble(txtNum.Text));
	total = total + totalPrices;
	lbxList.Items.Add(&quot;单价&quot; + txtPrice.Text + &quot;数量&quot; + txtNum.Text + &quot; &quot; 
				+ cbxType.SelectedItem + &quot; 合计：&quot; + totalPrices.ToString());
	lblResult.Text = total.ToString();
}
</code></pre><p><img src="https://i.loli.net/2021/10/10/ZwSdOQ4o5lfrJqj.jpg" alt="379505ecd1757b3ad430142ec19b24c"></p>
<p><strong>&ldquo;策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能&rdquo;</strong></p>
<p><strong>&ldquo;上例子的公共功能就是获得计算费用的结果，GetResult，这使得算法之间有了抽象的父类CashSuper&rdquo;</strong></p>
<p><strong>策略模式另一个优点就是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试</strong></p>
<p><strong>策略模式就是用来封装算法的，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性</strong></p>
<h2 id="3单一职责原则">3.单一职责原则</h2>
<p>&ldquo;如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏[ASD]&rdquo;</p>
<p>&ldquo;软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果你能够想到多于一个的东西去改变一个类，那么这个类就具有多于一个的职责[ASD]&rdquo;</p>
<h2 id="4开放-封闭原则">4.开放-封闭原则</h2>
<p><strong>开放-封闭原则，是说软件实体(类、模块、函数等等)应该是可拓展，但是不可修改</strong></p>
<p><strong>对于拓展是开放的(Open for extension)，对于更改是封闭的(Closed for modification)</strong></p>
<p>在最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。例如写个简单的加法程序，开始直接在client类中完成，但是得想到后来需要增加一些其他运算的功能，于是增加一个抽象的运算类，利用一些如继承，多态等来隔离具体加法、减法与client耦合，如后续要增加乘法除法功能，就不需要再去更改client以及加法减法的类了，而是增加乘法和除法的子类就好。</p>
<p><strong>面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。</strong></p>
<h2 id="5依赖倒转原则">5.依赖倒转原则</h2>
<p>抽象不应该依赖细节，细节应该依赖于抽象，说白了就是要对接口编程，不要对实现编程。</p>
<p><strong>A.高层模块不应该依赖低层模块。两个都应该依赖抽象。</strong></p>
<p><strong>B.抽象不应该依赖细节。细节应该依赖抽象。</strong></p>
<p>高层模块依赖于低层模块，如果需要用不同数据库或存储信息方式，那么连高层模块都不能使用了。</p>
<h3 id="里氏代换原则">#里氏代换原则</h3>
<p>一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型。</p>
<p>只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上添加新的行为，也就是因为这个才使得使用父类类型的模块在无需修改的情况下就可以扩展。</p>
<p>例如企鹅不能继承鸟类，虽然在生物学上企鹅是鸟类，但是在这说，企鹅不能飞，而鸟类指可以飞的，企鹅不能替换掉鸟类，所以不能继承。</p>
<h2 id="6装饰模式">6.装饰模式</h2>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
